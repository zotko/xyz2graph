{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"xyz2graph","text":"<p>A Python package for converting XYZ molecular files into interactive 3D visualizations and NetworkX graphs.</p> <p>Try it live \ud83d\ude80</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Interactive 3D molecular visualization using Plotly</li> <li>NetworkX graph conversion for analysis</li> <li>Command-line interface</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install xyz2graph\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>Dependencies: NumPy, Plotly, NetworkX</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from xyz2graph import MolGraph\n\n# Create molecular graph and read XYZ file\nmg = MolGraph()\nmg.read_xyz('molecule.xyz')\n\n# Convert to NetworkX graph\nG = mg.to_networkx()\n\n# Generate interactive 3D visualization\nfig = mg.to_plotly()\nfig.show()\n</code></pre>"},{"location":"#command-line","title":"Command Line","text":"<pre><code># Save visualization as HTML\nxyz2graph molecule.xyz\n\n# Specify output file\nxyz2graph molecule.xyz --output viz.html\n\n# Open directly in browser\nxyz2graph molecule.xyz --browser\n</code></pre>"},{"location":"#help-discussion","title":"Help &amp; Discussion","text":"<p>\ud83e\udeb2 Report a bug \u2728 Request a feature</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Read the documentation for guides, API reference, and examples.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the Contributing Guide for guidelines.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use xyz2graph in your research, please cite:</p> <pre><code>@misc{zotko2018xyz2graph,\n  author       = {Zotko, Mykola},\n  title        = {xyz2graph: Molecular Structure Visualization},\n  year         = {2018},\n  publisher    = {GitHub},\n  url          = {https://github.com/zotko/xyz2graph}\n}\n</code></pre> <p> </p>"},{"location":"cli/","title":"Command Line Interface","text":""},{"location":"cli/#usage","title":"Usage","text":"<pre><code>xyz2graph [-h] [-o OUTPUT] [-b] [--debug] [-r REMOVE] xyz_file\n</code></pre>"},{"location":"cli/#options","title":"Options","text":"<p>xyz_file Input XYZ file path containing molecular coordinates (required).</p> <p>-o, --output Custom output path for the HTML visualization. Defaults to input filename with .html extension.</p> <p>-b, --browser Launch visualization directly in default web browser instead of saving to file.</p> <p>-r, --remove Remove specific atoms using comma-separated indices or element symbols (e.g., \"1,2,H,O,5\" removes atoms at positions 1,2,5 and all H,O atoms). Element symbols must be properly capitalized.</p> <p>--debug Enable verbose logging for troubleshooting and development.</p> <p>-h, --help Display command-line options and usage information.</p>"},{"location":"cli/#examples","title":"Examples","text":"<pre><code># Basic usage - saves visualization as HTML in the same directory\nxyz2graph molecule.xyz\n\n# Save visualization with a specific name\nxyz2graph molecule.xyz -o viz.html\n\n# Open directly in browser without saving\nxyz2graph molecule.xyz -b\n\n# Remove hydrogens and oxygens from visualization\nxyz2graph molecule.xyz -r \"H,O\"\n\n# Remove specific atoms by index and element\nxyz2graph molecule.xyz -r \"1,2,H,O,5\"\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with xyz2graph.</p>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#creating-a-molecular-visualization","title":"Creating a Molecular Visualization","text":"<p>The most common use case is to create an interactive 3D visualization of a molecular structure:</p> <pre><code>from xyz2graph import MolGraph\n\n# Create a molecular graph\nmg = MolGraph()\n\n# Read structure from XYZ file\nmg.read_xyz('molecule.xyz')\n\n# Generate and display visualization\nfig = mg.to_plotly()\nfig.show()\n</code></pre>"},{"location":"getting-started/#network-analysis","title":"Network Analysis","text":"<p>Convert your molecular structure to a NetworkX graph for analysis:</p> <pre><code>import networkx as nx\n\n# Convert to NetworkX graph\nG = mg.to_networkx()\n\n# Calculate graph properties\nprint(f\"Graph density: {nx.density(G)}\")\n</code></pre>"},{"location":"getting-started/#structure-manipulation","title":"Structure Manipulation","text":"<p>Remove atoms for better visualization.</p> <pre><code># Remove all hydrogen atoms, modifying the original structure\nmg.remove(elements=['H'], inplace=True)\n\n# Remove both hydrogen and oxygen atoms, modifying the original structure\nmg.remove(elements=['H', 'O'], inplace=True)\n\n# Create a new molecule by removing hydrogens and specific atoms\n# The original molecule remains unchanged since inplace=False (default)\nnew_mg = mg.remove(elements=['H'], indices=[1, 5])\n</code></pre>"},{"location":"getting-started/#using-the-command-line","title":"Using the Command Line","text":"<p>For quick visualizations, you can use the command-line interface:</p> <pre><code># Basic usage - saves visualization as HTML in the same directory\nxyz2graph molecule.xyz\n\n# Save visualization to specific path\nxyz2graph molecule.xyz -o viz.html\n\n# Open directly in browser without saving\nxyz2graph molecule.xyz -b\n\n# Remove hydrogen atoms from visualization\nxyz2graph molecule.xyz -r \"H\"\n\n# Remove specific atoms by index (0-based)\nxyz2graph molecule.xyz -r \"0,1,2\"\n\n# Combine element and index removal\nxyz2graph molecule.xyz -r \"H,O,1,2,5\"\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>See the API documentation for detailed reference</li> <li>Learn about command-line options for batch processing</li> </ul> <p>For more specific issues raise an issue on our GitHub repository.</p>"},{"location":"license/","title":"License","text":"<pre><code>ISC License\n\nCopyright (c) 2018 Mykola Zotko\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n</code></pre>"},{"location":"python/","title":"Python API","text":"<p>Represents a molecular graph structure.</p> <p>Provides functionality to read molecular structure data from XYZ files, analyze molecular geometry, and visualize the molecular structure using Plotly.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>List[Atom]</code> <p>List of Atom objects representing the molecular structure. Defaults to an empty list.</p> <code>list()</code> <code>bonds</code> <code>List[Bond]</code> <p>List of Bond objects representing molecular connectivity. Defaults to an empty list.</p> <code>list()</code> <code>comment</code> <code>str</code> <p>Comment or description of the molecular structure. Defaults to an empty string.</p> <code>''</code> <code>default_radii</code> <code>Dict[str, float]</code> <p>Dictionary mapping element symbols to their default atomic radii. Defaults to internal _DEFAULT_RADII.</p> <code>lambda: dict(_DEFAULT_RADII)()</code> <code>cpk_colors</code> <code>Dict[str, str]</code> <p>Dictionary mapping element symbols to their CPK color scheme colors. Defaults to internal _DEFAULT_CPK_COLORS.</p> <code>lambda: dict(_DEFAULT_CPK_COLORS)()</code> <code>cpk_color_rest</code> <code>str</code> <p>Default color for elements not specified in cpk_colors. Defaults to \"pink\".</p> <code>'pink'</code> <p>Attributes:</p> Name Type Description <code>elements</code> <code>List[str]</code> <p>List of element symbols in order of appearance.</p> <code>indices</code> <code>List[int]</code> <p>List of atom indices in order.</p> <code>x</code> <code>List[float]</code> <p>List of x coordinates for all atoms in order.</p> <code>y</code> <code>List[float]</code> <p>List of y coordinates for all atoms in order.</p> <code>z</code> <code>List[float]</code> <p>List of z coordinates for all atoms in order.</p> <code>xyz</code> <code>NDArray[float64]</code> <p>Nx3 array of atomic coordinates.</p> <code>atomic_radii</code> <code>List[float]</code> <p>List of atomic radii in atom order.</p> <code>bond_lengths</code> <code>Dict[FrozenSet[int], float]</code> <p>Mapping of atom index pairs to bond lengths.</p> <code>adj_list</code> <code>Dict[int, Set[int]]</code> <p>Dictionary mapping atom indices to sets of bonded atom indices.</p> <code>adj_matrix</code> <code>NDArray[int_]</code> <p>Square matrix representing molecular connectivity.</p> Source code in <code>xyz2graph/graph.py</code> <pre><code>@dataclass\nclass MolGraph:\n    \"\"\"Represents a molecular graph structure.\n\n    Provides functionality to read molecular structure data from XYZ files, analyze molecular\n    geometry, and visualize the molecular structure using Plotly.\n\n    Args:\n        atoms (List[Atom], optional): List of Atom objects representing the molecular structure.\n            Defaults to an empty list.\n        bonds (List[Bond], optional): List of Bond objects representing molecular connectivity.\n            Defaults to an empty list.\n        comment (str, optional): Comment or description of the molecular structure.\n            Defaults to an empty string.\n        default_radii (Dict[str, float], optional): Dictionary mapping element symbols to their\n            default atomic radii. Defaults to internal _DEFAULT_RADII.\n        cpk_colors (Dict[str, str], optional): Dictionary mapping element symbols to their\n            CPK color scheme colors. Defaults to internal _DEFAULT_CPK_COLORS.\n        cpk_color_rest (str, optional): Default color for elements not specified in cpk_colors.\n            Defaults to \"pink\".\n\n    Attributes:\n        elements (List[str]): List of element symbols in order of appearance.\n        indices (List[int]): List of atom indices in order.\n        x (List[float]): List of x coordinates for all atoms in order.\n        y (List[float]): List of y coordinates for all atoms in order.\n        z (List[float]): List of z coordinates for all atoms in order.\n        xyz (NDArray[np.float64]): Nx3 array of atomic coordinates.\n        atomic_radii (List[float]): List of atomic radii in atom order.\n        bond_lengths (Dict[FrozenSet[int], float]): Mapping of atom index pairs to bond lengths.\n        adj_list (Dict[int, Set[int]]): Dictionary mapping atom indices\n            to sets of bonded atom indices.\n        adj_matrix (NDArray[np.int_]): Square matrix representing molecular connectivity.\n    \"\"\"\n\n    atoms: List[Atom] = field(default_factory=list)\n    bonds: List[Bond] = field(default_factory=list)\n    comment: str = field(default=\"\")\n\n    # Customizable parameters with defaults\n    default_radii: Dict[str, float] = field(default_factory=lambda: dict(_DEFAULT_RADII))\n    cpk_colors: Dict[str, str] = field(default_factory=lambda: dict(_DEFAULT_CPK_COLORS))\n    cpk_color_rest: str = field(default=\"pink\")\n\n    @property\n    def elements(self) -&gt; List[str]:\n        \"\"\"Get list of elements in the molecule.\n\n        Returns:\n            List[str]: List of element symbols in order of appearance.\n        \"\"\"\n        return [atom.element for atom in self.atoms]\n\n    @property\n    def indices(self) -&gt; List[int]:\n        \"\"\"Get list of atom indices.\n\n        Returns:\n            List[int]: List of atom indices in order.\n        \"\"\"\n        return [atom.index for atom in self.atoms]\n\n    @property\n    def x(self) -&gt; List[float]:\n        \"\"\"Get x coordinates of all atoms.\n\n        Returns:\n            List[float]: List of x coordinates in atom order.\n        \"\"\"\n        return [atom.x for atom in self.atoms]\n\n    @property\n    def y(self) -&gt; List[float]:\n        \"\"\"Get y coordinates of all atoms.\n\n        Returns:\n            List[float]: List of y coordinates in atom order.\n        \"\"\"\n        return [atom.y for atom in self.atoms]\n\n    @property\n    def z(self) -&gt; List[float]:\n        \"\"\"Get z coordinates of all atoms.\n\n        Returns:\n            List[float]: List of z coordinates in atom order.\n        \"\"\"\n        return [atom.z for atom in self.atoms]\n\n    @property\n    def xyz(self) -&gt; NDArray[np.float64]:\n        \"\"\"Get atomic coordinates as a numpy array.\n\n        Returns:\n            NDArray[np.float64]: Nx3 array of atomic coordinates.\n        \"\"\"\n        return np.array([[atom.x, atom.y, atom.z] for atom in self.atoms])\n\n    @property\n    def atomic_radii(self) -&gt; List[float]:\n        \"\"\"Get atomic radii for all atoms.\n\n        Returns:\n            List[float]: List of atomic radii in atom order.\n        \"\"\"\n        return [atom.radius for atom in self.atoms]\n\n    @property\n    def bond_lengths(self) -&gt; Dict[FrozenSet[int], float]:\n        \"\"\"Get dictionary of bond lengths.\n\n        Returns:\n            Dict[FrozenSet[int], float]: Mapping of atom index pairs to bond lengths.\n        \"\"\"\n        return {bond.indices: bond.length for bond in self.bonds}\n\n    @property\n    def adj_list(self) -&gt; Dict[int, Set[int]]:\n        \"\"\"Get adjacency list representation of molecular graph.\n\n        Returns:\n            Dict[int, Set[int]]: Dictionary mapping atom indices to sets of bonded atom indices.\n        \"\"\"\n        adj: Dict[int, Set[int]] = {}\n        for bond in self.bonds:\n            i1, i2 = tuple(bond.indices)\n            adj.setdefault(i1, set()).add(i2)\n            adj.setdefault(i2, set()).add(i1)\n        return adj\n\n    @property\n    def adj_matrix(self) -&gt; NDArray[np.int_]:\n        \"\"\"Get adjacency matrix representation of molecular graph.\n\n        Returns:\n            NDArray[np.int_]: A square matrix where entry (i,j) is 1 if atoms i and j\n                are bonded and 0 otherwise.\n        \"\"\"\n        n = len(self.atoms)\n        matrix = np.zeros((n, n), dtype=np.int_)\n        for bond in self.bonds:\n            i, j = tuple(bond.indices)\n            matrix[i, j] = matrix[j, i] = 1\n        return matrix\n\n    def read_xyz(self, file_path: Union[str, Path]) -&gt; None:\n        \"\"\"Read molecular structure from XYZ file.\n\n        Args:\n            file_path (Union[str, Path]): Path to XYZ format file.\n\n        Raises:\n            FileNotFoundError: If the specified file does not exist.\n            ValueError: If file format is invalid or contains unknown elements.\n        \"\"\"\n        file_path = Path(file_path)\n        if not file_path.exists():\n            raise FileNotFoundError(f\"XYZ file not found: {file_path}\")\n\n        try:\n            lines = file_path.read_text().splitlines()\n\n            try:\n                n_atoms = int(lines[0].strip())\n            except (IndexError, ValueError) as err:\n                raise ValueError(\"First line must be an integer (number of atoms)\") from err\n\n            self.comment = lines[1] if len(lines) &gt; 1 else \"\"\n\n            atoms = []\n            for i, line in enumerate(lines[2:], start=0):\n                parts = line.split()\n\n                try:\n                    element = parts[0]\n                    if element not in self.default_radii:\n                        raise ValueError(f\"Unknown element symbol: {element}\")\n\n                    x, y, z = map(float, parts[1:4])\n\n                    atoms.append(\n                        Atom(\n                            element=element,\n                            x=x,\n                            y=y,\n                            z=z,\n                            index=i,\n                            radius=self.default_radii[element],\n                        )\n                    )\n                except (IndexError, ValueError) as err:\n                    raise ValueError(\n                        f\"Invalid format in line {i+3}, expected: element x y z\"\n                    ) from err\n\n            if len(atoms) != n_atoms:\n                logger.warning(\n                    f\"Number of atoms in file ({len(atoms)}) doesn't match the number specified \"\n                    f\"in the first line ({n_atoms})\"\n                )\n\n            self.atoms = atoms\n            self._generate_bonds()\n\n        except Exception as e:\n            logger.error(f\"Error reading XYZ file: {e}\")\n            raise\n\n    def _generate_bonds(self) -&gt; None:\n        \"\"\"Generate bonds based on atomic distances.\n\n        Updates the bonds list based on distance criteria between atoms.\n        \"\"\"\n        self.bonds.clear()\n\n        distances = self.distance_matrix()\n\n        # Calculate bonding threshold matrix\n        radii = np.array(self.atomic_radii)\n        thresholds = (radii[:, np.newaxis] + radii) * 1.3\n\n        # Find bonded atoms (creates adjacency matrix internally)\n        adj_matrix = np.logical_and(0.1 &lt; distances, thresholds &gt; distances).astype(np.int_)\n\n        # Create Bond objects from adjacency matrix\n        for i, j in zip(*np.nonzero(adj_matrix)):\n            if i &lt; j:\n                self.bonds.append(Bond(self.atoms[i], self.atoms[j]))\n\n    def distance_matrix(self) -&gt; NDArray[np.float64]:\n        \"\"\"Calculates the matrix of interatomic distances using optimized memory handling.\n\n        Attempts to use fast vectorized calculation first, then falls back to a memory-efficient\n        loop-based method if memory constraints are encountered.\n\n        Returns:\n            NDArray[np.float64]: A square matrix where entry (i,j) represents the\n                Euclidean distance between atoms i and j in Angstroms.\n        \"\"\"\n        try:\n            distances = self.xyz[:, np.newaxis, :] - self.xyz\n            return np.sqrt(np.einsum(\"ijk,ijk-&gt;ij\", distances, distances))\n        except MemoryError:\n            # Fall back to loop-based method\n            n_atoms = len(self.atoms)\n            logger.info(\"Using memory-efficient method for distance calculation\")\n            distance_matrix = np.zeros((n_atoms, n_atoms), dtype=np.float64)\n            for i in range(n_atoms):\n                diff = self.xyz[i] - self.xyz\n                distance_matrix[i] = np.sqrt(np.sum(diff * diff, axis=1))\n            return distance_matrix\n\n    def formula(self) -&gt; str:\n        \"\"\"Generate molecular formula in Hill notation.\n\n        Returns:\n            str: Molecular formula in Hill notation.\n        \"\"\"\n        if not self.atoms:\n            return \"\"\n\n        element_counts = Counter(atom.element for atom in self.atoms)\n        formula_parts = []\n\n        # Carbon and Hydrogen first\n        if \"C\" in element_counts:\n            count = element_counts.pop(\"C\")\n            formula_parts.append(f\"C{count if count &gt; 1 else ''}\")\n\n            if \"H\" in element_counts:\n                count = element_counts.pop(\"H\")\n                formula_parts.append(f\"H{count if count &gt; 1 else ''}\")\n\n        # Add remaining elements alphabetically\n        for element in sorted(element_counts):\n            count = element_counts[element]\n            formula_parts.append(f\"{element}{count if count &gt; 1 else ''}\")\n\n        return \"\".join(formula_parts)\n\n    def set_element_radius(self, element: str, radius: float) -&gt; None:\n        \"\"\"Set the reference radius for a specific element.\n\n        Args:\n            element (str): Chemical element symbol.\n            radius (float): New atomic radius value.\n        \"\"\"\n        self.default_radii[element] = radius\n        # Update radii for existing atoms of this element\n        for atom in self.atoms:\n            if atom.element == element:\n                atom.radius = radius\n        # Regenerate bonds with new radii\n        self._generate_bonds()\n\n    def remove(\n        self,\n        indices: Optional[List[int]] = None,\n        elements: Optional[List[str]] = None,\n        inplace: bool = False,\n    ) -&gt; Optional[\"MolGraph\"]:\n        \"\"\"Remove atoms by indices and/or elements.\n\n        Args:\n            indices (List[int], optional): List of atom indices to remove.\n            elements (List[str], optional): List of element symbols to remove.\n            inplace (bool): If True, modify this instance. If False, return a new instance.\n\n        Returns:\n            Optional[MolGraph]: New MolGraph instance if inplace=False, None if inplace=True.\n\n        Raises:\n            IndexError: If any index is out of range.\n            ValueError: If attempting to remove all atoms or if unknown elements specified.\n        \"\"\"\n        mask = [True] * len(self.atoms)\n\n        if indices is not None:\n            if any(i &lt; 0 or i &gt;= len(self.atoms) for i in indices):\n                raise IndexError(\"Atom index out of range\")\n            for idx in indices:\n                mask[idx] = False\n\n        if elements is not None:\n            found_elements = {atom.element for atom in self.atoms if atom.element in elements}\n            unused_elements = set(elements) - found_elements\n            if unused_elements:\n                logger.warning(\n                    f\"Element(s) not found: {', '.join(sorted(unused_elements))}. \"\n                    \"Use proper case (e.g., 'H' not 'h')\"\n                )\n            mask = [m and atom.element not in elements for m, atom in zip(mask, self.atoms)]\n\n        if not any(mask):\n            raise ValueError(\"Cannot remove all atoms from molecule\")\n\n        filtered_atoms = list(compress(self.atoms, mask))\n\n        if inplace:\n            self.atoms = filtered_atoms\n            self._generate_bonds()\n            return None\n\n        new_mol = MolGraph()\n        new_mol.atoms = filtered_atoms\n        new_mol.comment = self.comment\n        new_mol.default_radii = self.default_radii.copy()\n        new_mol.cpk_colors = self.cpk_colors.copy()\n        new_mol.cpk_color_rest = self.cpk_color_rest\n        new_mol._generate_bonds()\n        return new_mol\n\n    def to_networkx(self) -&gt; nx.Graph:\n        \"\"\"Convert molecular structure to NetworkX graph.\n\n        Returns:\n            nx.Graph: NetworkX graph with atoms as nodes and bonds as edges.\n        \"\"\"\n        logger.debug(\"Creating NetworkX graph\")\n\n        G = nx.Graph()\n\n        # Add nodes with attributes\n        for atom in self.atoms:\n            G.add_node(atom.index, element=atom.element, xyz=(atom.x, atom.y, atom.z))\n\n        # Add edges with attributes\n        for bond in self.bonds:\n            G.add_edge(bond.atom1.index, bond.atom2.index, length=bond.length)\n\n        return G\n\n    # Define dummy method to_plotly()\n    def to_plotly(self, config: Optional[VisualizationConfig] = None) -&gt; go.Figure:\n        \"\"\"Convert molecular structure to Plotly figure.\n\n        Args:\n            config (VisualizationConfig, optional): Visualization configuration parameters.\n\n        Returns:\n            go.Figure: Interactive molecular visualization as Plotly figure.\n        \"\"\"\n        logger.debug(\"Creating Plotly figure\")\n\n        return create_visualization(self, config)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Get the number of atoms in the molecule.\n\n        Returns:\n            int: Total number of atoms.\n        \"\"\"\n        return len(self.atoms)\n\n    def __getitem__(self, index: int) -&gt; Atom:\n        \"\"\"Get atom at specified index.\n\n        Args:\n            index (int): Zero-based index of the atom.\n\n        Returns:\n            Atom: Atom object at the specified index.\n\n        Raises:\n            IndexError: If index is out of range.\n        \"\"\"\n        return self.atoms[index]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Creates a simplified string representation of the molecular graph.\n\n        Generates a string representation showing the molecular formula in Hill notation\n        along with basic structural information about the number of atoms and bonds.\n\n        Returns:\n            str: A string in the format \"MolGraph(formula: num_atoms atoms, num_bonds bonds)\"\n                or \"MolGraph(empty)\" for an empty molecule.\n\n        Examples:\n            &gt;&gt;&gt; mol = MolGraph()  # empty molecule\n            &gt;&gt;&gt; repr(mol)\n            'MolGraph(empty)'\n\n            &gt;&gt;&gt; mol = MolGraph(atoms=[...])  # molecule with CH4 structure\n            &gt;&gt;&gt; repr(mol)\n            'MolGraph(CH4: 5 atoms, 4 bonds)'\n        \"\"\"\n        if not self.atoms:\n            return \"MolGraph(empty)\"\n\n        return f\"MolGraph({self.formula()}: {len(self.atoms)} atoms, {len(self.bonds)} bonds)\"\n</code></pre>"},{"location":"python/#xyz2graph.graph.MolGraph.elements","title":"elements  <code>property</code>","text":"<pre><code>elements: List[str]\n</code></pre> <p>Get list of elements in the molecule.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of element symbols in order of appearance.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.indices","title":"indices  <code>property</code>","text":"<pre><code>indices: List[int]\n</code></pre> <p>Get list of atom indices.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: List of atom indices in order.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.x","title":"x  <code>property</code>","text":"<pre><code>x: List[float]\n</code></pre> <p>Get x coordinates of all atoms.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: List of x coordinates in atom order.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.y","title":"y  <code>property</code>","text":"<pre><code>y: List[float]\n</code></pre> <p>Get y coordinates of all atoms.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: List of y coordinates in atom order.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.z","title":"z  <code>property</code>","text":"<pre><code>z: List[float]\n</code></pre> <p>Get z coordinates of all atoms.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: List of z coordinates in atom order.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.xyz","title":"xyz  <code>property</code>","text":"<pre><code>xyz: NDArray[float64]\n</code></pre> <p>Get atomic coordinates as a numpy array.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: Nx3 array of atomic coordinates.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.atomic_radii","title":"atomic_radii  <code>property</code>","text":"<pre><code>atomic_radii: List[float]\n</code></pre> <p>Get atomic radii for all atoms.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: List of atomic radii in atom order.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.bond_lengths","title":"bond_lengths  <code>property</code>","text":"<pre><code>bond_lengths: Dict[FrozenSet[int], float]\n</code></pre> <p>Get dictionary of bond lengths.</p> <p>Returns:</p> Type Description <code>Dict[FrozenSet[int], float]</code> <p>Dict[FrozenSet[int], float]: Mapping of atom index pairs to bond lengths.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.adj_list","title":"adj_list  <code>property</code>","text":"<pre><code>adj_list: Dict[int, Set[int]]\n</code></pre> <p>Get adjacency list representation of molecular graph.</p> <p>Returns:</p> Type Description <code>Dict[int, Set[int]]</code> <p>Dict[int, Set[int]]: Dictionary mapping atom indices to sets of bonded atom indices.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.adj_matrix","title":"adj_matrix  <code>property</code>","text":"<pre><code>adj_matrix: NDArray[int_]\n</code></pre> <p>Get adjacency matrix representation of molecular graph.</p> <p>Returns:</p> Type Description <code>NDArray[int_]</code> <p>NDArray[np.int_]: A square matrix where entry (i,j) is 1 if atoms i and j are bonded and 0 otherwise.</p>"},{"location":"python/#xyz2graph.graph.MolGraph.read_xyz","title":"read_xyz","text":"<pre><code>read_xyz(file_path: Union[str, Path]) -&gt; None\n</code></pre> <p>Read molecular structure from XYZ file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]</code> <p>Path to XYZ format file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified file does not exist.</p> <code>ValueError</code> <p>If file format is invalid or contains unknown elements.</p> Source code in <code>xyz2graph/graph.py</code> <pre><code>def read_xyz(self, file_path: Union[str, Path]) -&gt; None:\n    \"\"\"Read molecular structure from XYZ file.\n\n    Args:\n        file_path (Union[str, Path]): Path to XYZ format file.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        ValueError: If file format is invalid or contains unknown elements.\n    \"\"\"\n    file_path = Path(file_path)\n    if not file_path.exists():\n        raise FileNotFoundError(f\"XYZ file not found: {file_path}\")\n\n    try:\n        lines = file_path.read_text().splitlines()\n\n        try:\n            n_atoms = int(lines[0].strip())\n        except (IndexError, ValueError) as err:\n            raise ValueError(\"First line must be an integer (number of atoms)\") from err\n\n        self.comment = lines[1] if len(lines) &gt; 1 else \"\"\n\n        atoms = []\n        for i, line in enumerate(lines[2:], start=0):\n            parts = line.split()\n\n            try:\n                element = parts[0]\n                if element not in self.default_radii:\n                    raise ValueError(f\"Unknown element symbol: {element}\")\n\n                x, y, z = map(float, parts[1:4])\n\n                atoms.append(\n                    Atom(\n                        element=element,\n                        x=x,\n                        y=y,\n                        z=z,\n                        index=i,\n                        radius=self.default_radii[element],\n                    )\n                )\n            except (IndexError, ValueError) as err:\n                raise ValueError(\n                    f\"Invalid format in line {i+3}, expected: element x y z\"\n                ) from err\n\n        if len(atoms) != n_atoms:\n            logger.warning(\n                f\"Number of atoms in file ({len(atoms)}) doesn't match the number specified \"\n                f\"in the first line ({n_atoms})\"\n            )\n\n        self.atoms = atoms\n        self._generate_bonds()\n\n    except Exception as e:\n        logger.error(f\"Error reading XYZ file: {e}\")\n        raise\n</code></pre>"},{"location":"python/#xyz2graph.graph.MolGraph.distance_matrix","title":"distance_matrix","text":"<pre><code>distance_matrix() -&gt; NDArray[np.float64]\n</code></pre> <p>Calculates the matrix of interatomic distances using optimized memory handling.</p> <p>Attempts to use fast vectorized calculation first, then falls back to a memory-efficient loop-based method if memory constraints are encountered.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>NDArray[np.float64]: A square matrix where entry (i,j) represents the Euclidean distance between atoms i and j in Angstroms.</p> Source code in <code>xyz2graph/graph.py</code> <pre><code>def distance_matrix(self) -&gt; NDArray[np.float64]:\n    \"\"\"Calculates the matrix of interatomic distances using optimized memory handling.\n\n    Attempts to use fast vectorized calculation first, then falls back to a memory-efficient\n    loop-based method if memory constraints are encountered.\n\n    Returns:\n        NDArray[np.float64]: A square matrix where entry (i,j) represents the\n            Euclidean distance between atoms i and j in Angstroms.\n    \"\"\"\n    try:\n        distances = self.xyz[:, np.newaxis, :] - self.xyz\n        return np.sqrt(np.einsum(\"ijk,ijk-&gt;ij\", distances, distances))\n    except MemoryError:\n        # Fall back to loop-based method\n        n_atoms = len(self.atoms)\n        logger.info(\"Using memory-efficient method for distance calculation\")\n        distance_matrix = np.zeros((n_atoms, n_atoms), dtype=np.float64)\n        for i in range(n_atoms):\n            diff = self.xyz[i] - self.xyz\n            distance_matrix[i] = np.sqrt(np.sum(diff * diff, axis=1))\n        return distance_matrix\n</code></pre>"},{"location":"python/#xyz2graph.graph.MolGraph.formula","title":"formula","text":"<pre><code>formula() -&gt; str\n</code></pre> <p>Generate molecular formula in Hill notation.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Molecular formula in Hill notation.</p> Source code in <code>xyz2graph/graph.py</code> <pre><code>def formula(self) -&gt; str:\n    \"\"\"Generate molecular formula in Hill notation.\n\n    Returns:\n        str: Molecular formula in Hill notation.\n    \"\"\"\n    if not self.atoms:\n        return \"\"\n\n    element_counts = Counter(atom.element for atom in self.atoms)\n    formula_parts = []\n\n    # Carbon and Hydrogen first\n    if \"C\" in element_counts:\n        count = element_counts.pop(\"C\")\n        formula_parts.append(f\"C{count if count &gt; 1 else ''}\")\n\n        if \"H\" in element_counts:\n            count = element_counts.pop(\"H\")\n            formula_parts.append(f\"H{count if count &gt; 1 else ''}\")\n\n    # Add remaining elements alphabetically\n    for element in sorted(element_counts):\n        count = element_counts[element]\n        formula_parts.append(f\"{element}{count if count &gt; 1 else ''}\")\n\n    return \"\".join(formula_parts)\n</code></pre>"},{"location":"python/#xyz2graph.graph.MolGraph.set_element_radius","title":"set_element_radius","text":"<pre><code>set_element_radius(element: str, radius: float) -&gt; None\n</code></pre> <p>Set the reference radius for a specific element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>Chemical element symbol.</p> required <code>radius</code> <code>float</code> <p>New atomic radius value.</p> required Source code in <code>xyz2graph/graph.py</code> <pre><code>def set_element_radius(self, element: str, radius: float) -&gt; None:\n    \"\"\"Set the reference radius for a specific element.\n\n    Args:\n        element (str): Chemical element symbol.\n        radius (float): New atomic radius value.\n    \"\"\"\n    self.default_radii[element] = radius\n    # Update radii for existing atoms of this element\n    for atom in self.atoms:\n        if atom.element == element:\n            atom.radius = radius\n    # Regenerate bonds with new radii\n    self._generate_bonds()\n</code></pre>"},{"location":"python/#xyz2graph.graph.MolGraph.remove","title":"remove","text":"<pre><code>remove(\n    indices: Optional[List[int]] = None,\n    elements: Optional[List[str]] = None,\n    inplace: bool = False,\n) -&gt; Optional[MolGraph]\n</code></pre> <p>Remove atoms by indices and/or elements.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>List[int]</code> <p>List of atom indices to remove.</p> <code>None</code> <code>elements</code> <code>List[str]</code> <p>List of element symbols to remove.</p> <code>None</code> <code>inplace</code> <code>bool</code> <p>If True, modify this instance. If False, return a new instance.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[MolGraph]</code> <p>Optional[MolGraph]: New MolGraph instance if inplace=False, None if inplace=True.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If any index is out of range.</p> <code>ValueError</code> <p>If attempting to remove all atoms or if unknown elements specified.</p> Source code in <code>xyz2graph/graph.py</code> <pre><code>def remove(\n    self,\n    indices: Optional[List[int]] = None,\n    elements: Optional[List[str]] = None,\n    inplace: bool = False,\n) -&gt; Optional[\"MolGraph\"]:\n    \"\"\"Remove atoms by indices and/or elements.\n\n    Args:\n        indices (List[int], optional): List of atom indices to remove.\n        elements (List[str], optional): List of element symbols to remove.\n        inplace (bool): If True, modify this instance. If False, return a new instance.\n\n    Returns:\n        Optional[MolGraph]: New MolGraph instance if inplace=False, None if inplace=True.\n\n    Raises:\n        IndexError: If any index is out of range.\n        ValueError: If attempting to remove all atoms or if unknown elements specified.\n    \"\"\"\n    mask = [True] * len(self.atoms)\n\n    if indices is not None:\n        if any(i &lt; 0 or i &gt;= len(self.atoms) for i in indices):\n            raise IndexError(\"Atom index out of range\")\n        for idx in indices:\n            mask[idx] = False\n\n    if elements is not None:\n        found_elements = {atom.element for atom in self.atoms if atom.element in elements}\n        unused_elements = set(elements) - found_elements\n        if unused_elements:\n            logger.warning(\n                f\"Element(s) not found: {', '.join(sorted(unused_elements))}. \"\n                \"Use proper case (e.g., 'H' not 'h')\"\n            )\n        mask = [m and atom.element not in elements for m, atom in zip(mask, self.atoms)]\n\n    if not any(mask):\n        raise ValueError(\"Cannot remove all atoms from molecule\")\n\n    filtered_atoms = list(compress(self.atoms, mask))\n\n    if inplace:\n        self.atoms = filtered_atoms\n        self._generate_bonds()\n        return None\n\n    new_mol = MolGraph()\n    new_mol.atoms = filtered_atoms\n    new_mol.comment = self.comment\n    new_mol.default_radii = self.default_radii.copy()\n    new_mol.cpk_colors = self.cpk_colors.copy()\n    new_mol.cpk_color_rest = self.cpk_color_rest\n    new_mol._generate_bonds()\n    return new_mol\n</code></pre>"},{"location":"python/#xyz2graph.graph.MolGraph.to_networkx","title":"to_networkx","text":"<pre><code>to_networkx() -&gt; nx.Graph\n</code></pre> <p>Convert molecular structure to NetworkX graph.</p> <p>Returns:</p> Type Description <code>Graph</code> <p>nx.Graph: NetworkX graph with atoms as nodes and bonds as edges.</p> Source code in <code>xyz2graph/graph.py</code> <pre><code>def to_networkx(self) -&gt; nx.Graph:\n    \"\"\"Convert molecular structure to NetworkX graph.\n\n    Returns:\n        nx.Graph: NetworkX graph with atoms as nodes and bonds as edges.\n    \"\"\"\n    logger.debug(\"Creating NetworkX graph\")\n\n    G = nx.Graph()\n\n    # Add nodes with attributes\n    for atom in self.atoms:\n        G.add_node(atom.index, element=atom.element, xyz=(atom.x, atom.y, atom.z))\n\n    # Add edges with attributes\n    for bond in self.bonds:\n        G.add_edge(bond.atom1.index, bond.atom2.index, length=bond.length)\n\n    return G\n</code></pre>"},{"location":"python/#xyz2graph.graph.MolGraph.to_plotly","title":"to_plotly","text":"<pre><code>to_plotly(\n    config: Optional[VisualizationConfig] = None,\n) -&gt; go.Figure\n</code></pre> <p>Convert molecular structure to Plotly figure.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>VisualizationConfig</code> <p>Visualization configuration parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: Interactive molecular visualization as Plotly figure.</p> Source code in <code>xyz2graph/graph.py</code> <pre><code>def to_plotly(self, config: Optional[VisualizationConfig] = None) -&gt; go.Figure:\n    \"\"\"Convert molecular structure to Plotly figure.\n\n    Args:\n        config (VisualizationConfig, optional): Visualization configuration parameters.\n\n    Returns:\n        go.Figure: Interactive molecular visualization as Plotly figure.\n    \"\"\"\n    logger.debug(\"Creating Plotly figure\")\n\n    return create_visualization(self, config)\n</code></pre>"}]}