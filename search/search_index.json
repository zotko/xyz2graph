{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"xyz2graph","text":"<p>Welcome to xyz2graph's documentation! This Python package provides tools for reading XYZ molecular structure files and creating interactive 3D visualizations.</p> \ud83d\udc46 Try me!"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Read and analyze XYZ molecular structure files</li> <li>Generate interactive 3D visualizations with Plotly</li> <li>Export to NetworkX graphs for advanced analysis</li> <li>Command-line interface for quick visualizations</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install xyz2graph\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>Plotly</li> <li>NetworkX</li> <li>NumPy</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the ISC License. See the LICENSE file for details.</p>"},{"location":"cli/","title":"Command Line Interface","text":""},{"location":"cli/#usage","title":"Usage","text":"<pre><code>xyz2graph [-h] [-o OUTPUT] [-b] [--debug] [-f FILTER] xyz_file\n</code></pre>"},{"location":"cli/#options","title":"Options","text":"<p>xyz_file Input XYZ file path containing molecular coordinates (required).</p> <p>-o, --output Custom output path for the HTML visualization. Defaults to input filename with .html extension.</p> <p>-b, --browser Launch visualization directly in default web browser instead of saving to file.</p> <p>-f, --filter Filter out specific atoms using comma-separated indices or element symbols (e.g., \"1,2,H,O,5\" removes atoms at positions 1,2,5 and all H,O atoms). Element symbols must be properly capitalized.</p> <p>--debug Enable verbose logging for troubleshooting and development.</p> <p>-h, --help Display command-line options and usage information.</p>"},{"location":"cli/#examples","title":"Examples","text":"<pre><code># Basic usage - saves visualization as HTML in the same directory\nxyz2graph molecule.xyz\n\n# Save visualization with a specific name\nxyz2graph molecule.xyz --output my-molecule.html\n\n# Open directly in browser without saving\nxyz2graph molecule.xyz --browser\n\n# Remove hydrogens and oxygens from visualization\nxyz2graph molecule.xyz --filter \"H,O\"\n\n# Remove specific atoms by index and element\nxyz2graph molecule.xyz --filter \"1,2,H,O,5\"\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with xyz2graph.</p>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#creating-a-molecular-visualization","title":"Creating a Molecular Visualization","text":"<p>The most common use case is to create an interactive 3D visualization of a molecular structure:</p> <pre><code>from xyz2graph import MolGraph\n\n# Create a molecular graph\nmg = MolGraph()\n\n# Read structure from XYZ file\nmg.read_xyz('molecule.xyz')\n\n# Generate and display visualization\nfig = mg.to_plotly()\nfig.show()\n</code></pre>"},{"location":"getting-started/#advanced-reading-options","title":"Advanced Reading Options","text":"<p>Control how files are read and validated:</p> <pre><code># Read raw coordinates (no header)\nmg.read_xyz('coords.xyz', xyz_start=0)\n\n# Read coordinates from custom start line\nmg.read_xyz('custom.xyz', xyz_start=3)\n\n# Validate coordinate count against header\nmg.read_xyz('molecule.xyz', validate=True)\n</code></pre>"},{"location":"getting-started/#network-analysis","title":"Network Analysis","text":"<p>Convert your molecular structure to a NetworkX graph for analysis:</p> <pre><code># Convert to NetworkX graph\nG = mg.to_networkx()\n\n# Calculate graph properties\nprint(f\"Graph density: {nx.density(G)}\")\n</code></pre>"},{"location":"getting-started/#visualization-settings","title":"Visualization Settings","text":"<p>You can customize the appearance of your molecular visualization:</p> <pre><code>config = {\n    \"atom_size\": 7,\n    \"atom_opacity\": 0.8,\n    \"atom_border_color\": \"lightgray\",\n    \"atom_border_width\": 2,\n    \"bond_color\": \"grey\",\n    \"bond_width\": 2,\n    \"show_grid\": False,\n    \"label_offset\": 15,\n    \"bond_label_color\": \"steelblue\"\n}\n\n# Create visualization with custom settings\nfig = mg.to_plotly(config=config)\nfig.show()\n</code></pre>"},{"location":"getting-started/#structure-manipulation","title":"Structure Manipulation","text":"<pre><code># Remove all hydrogen atoms\nmg.filter(elements=['H'], inplace=True)\n\n# Remove multiple element types\nmg.filter(elements=['H', 'O'], inplace=True)\n\n# Remove all hydrogen atoms and atoms at indices 1 and 5\nnew_mg = mg.filter(elements=['H'], indices=[1,5])\n</code></pre>"},{"location":"getting-started/#using-the-command-line","title":"Using the Command Line","text":"<p>For quick visualizations, you can use the command-line interface:</p> <pre><code># Basic usage - saves visualization as HTML in the same directory\nxyz2graph molecule.xyz\n\n# Save visualization to specific path\nxyz2graph molecule.xyz --output viz.html\n\n# Open directly in browser without saving\nxyz2graph molecule.xyz --browser\n\n# Remove hydrogen atoms from visualization\nxyz2graph molecule.xyz --filter \"H\"\n\n# Remove specific atoms by index (0-based)\nxyz2graph molecule.xyz --filter \"0,1,2\"\n\n# Combine element and index filtering\nxyz2graph molecule.xyz --filter \"H,O,1,2,5\"\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>See the API documentation for detailed reference</li> <li>Learn about command-line options for batch processing</li> </ul>"},{"location":"getting-started/#xyz-file-format","title":"XYZ File Format","text":"<p>The XYZ file format is a simple text format for molecular structures:</p> <pre><code>3\nWater\nO  0.000000  0.000000  0.000000\nH  0.758602  0.000000  0.504284\nH  0.758602  0.000000 -0.504284\n</code></pre> <p>Where:</p> <ul> <li>First line: Number of atoms</li> <li>Second line: Comment or title</li> <li>Following lines: Element and coordinates (x, y, z) in Angstroms</li> </ul>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#file-not-found","title":"File Not Found","text":"<p>If you get a <code>FileNotFoundError</code>, check that:</p> <ul> <li>The XYZ file exists in the specified path</li> <li>You have read permissions for the file</li> <li>The path is correct relative to your working directory</li> </ul>"},{"location":"getting-started/#invalid-file-format","title":"Invalid File Format","text":"<p>If you get a <code>ValueError</code> when reading an XYZ file:</p> <ul> <li>Verify the file follows the XYZ format</li> <li>Check for missing or extra whitespace</li> <li>Ensure coordinates are valid numbers</li> <li>Verify element symbols are valid</li> <li>If your file doesn't have the standard header (atom count and comment), use the <code>xyz_start</code> parameter to specify where coordinates begin:   <pre><code># Start reading coordinates from first line (no header)\nmg.read_xyz(\"molecule.xyz\", xyz_start=0)\n\n# Start reading coordinates from line 3\nmg.read_xyz(\"molecule.xyz\", xyz_start=3)\n</code></pre></li> </ul> <p>For more specific issues raise an issue on our GitHub repository.</p>"},{"location":"license/","title":"License","text":"<pre><code>ISC License\n\nCopyright (c) 2018 Mykola Zotko\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n</code></pre>"},{"location":"python/","title":"Python API","text":""},{"location":"python/#xyz2graph.xyz2graph.MolGraph","title":"<code>xyz2graph.xyz2graph.MolGraph</code>  <code>dataclass</code>","text":"<p>Represents a molecular graph structure.</p> <p>This class provides functionality to read molecular structure data from XYZ files, analyze molecular geometry, and visualize the molecular structure using Plotly.</p> <p>Attributes:</p> Name Type Description <code>elements</code> <code>List[str]</code> <p>List of atomic elements in the molecule.</p> <code>x</code> <code>List[float]</code> <p>List of x-coordinates for each atom.</p> <code>y</code> <code>List[float]</code> <p>List of y-coordinates for each atom.</p> <code>z</code> <code>List[float]</code> <p>List of z-coordinates for each atom.</p> <code>comment</code> <code>str</code> <p>Optional comment or title from the XYZ file.</p> <code>adj_list</code> <code>Dict[int, Set[int]]</code> <p>Dictionary mapping atom indices to their connected neighbors.</p> <code>atomic_radii</code> <code>List[float]</code> <p>List of atomic radii for each atom.</p> <code>bond_lengths</code> <code>Dict[FrozenSet[int], float]</code> <p>Dictionary mapping pairs of connected atoms to their bond lengths.</p> <code>adj_matrix</code> <code>NDArray[int_] | None</code> <p>Numpy array representing the adjacency matrix of the molecular graph.</p> <code>indices</code> <code>List[int]</code> <p>List of original indices for each atom, preserved during filtering operations. Maps current atoms back to their positions in the original structure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mg = MolGraph()\n&gt;&gt;&gt; mg.read_xyz('molecule.xyz')\n&gt;&gt;&gt; print(mg.formula())\n'C2H6O'\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>@dataclass\nclass MolGraph:\n    \"\"\"Represents a molecular graph structure.\n\n    This class provides functionality to read molecular structure data from XYZ files,\n    analyze molecular geometry, and visualize the molecular structure using Plotly.\n\n    Attributes:\n        elements (List[str]): List of atomic elements in the molecule.\n        x (List[float]): List of x-coordinates for each atom.\n        y (List[float]): List of y-coordinates for each atom.\n        z (List[float]): List of z-coordinates for each atom.\n        comment (str): Optional comment or title from the XYZ file.\n        adj_list (Dict[int, Set[int]]): Dictionary mapping atom indices to their\n            connected neighbors.\n        atomic_radii (List[float]): List of atomic radii for each atom.\n        bond_lengths (Dict[FrozenSet[int], float]): Dictionary mapping pairs of\n            connected atoms to their bond lengths.\n        adj_matrix (NDArray[np.int_] | None): Numpy array representing the adjacency\n            matrix of the molecular graph.\n        indices (List[int]): List of original indices for each atom, preserved during filtering\n            operations. Maps current atoms back to their positions in the original structure.\n\n    Examples:\n        &gt;&gt;&gt; mg = MolGraph()\n        &gt;&gt;&gt; mg.read_xyz('molecule.xyz')\n        &gt;&gt;&gt; print(mg.formula())\n        'C2H6O'\n    \"\"\"\n\n    elements: List[str] = field(default_factory=list)\n    x: List[float] = field(default_factory=list)\n    y: List[float] = field(default_factory=list)\n    z: List[float] = field(default_factory=list)\n    comment: str = field(default=\"\")\n    adj_list: Dict[int, Set[int]] = field(default_factory=dict)\n    atomic_radii: List[float] = field(default_factory=list)\n    bond_lengths: Dict[FrozenSet[int], float] = field(default_factory=dict)\n    adj_matrix: Union[NDArray[np.int_], None] = field(default=None)\n    indices: List[int] = field(default_factory=list)\n\n    # Customizable parameters with defaults\n    default_radii: Dict[str, float] = field(default_factory=lambda: dict(DEFAULT_RADII))\n    cpk_colors: Dict[str, str] = field(default_factory=lambda: dict(DEFAULT_CPK_COLORS))\n    cpk_color_rest: str = field(default=\"pink\")\n\n    def set_element_radius(self, element: str, radius: float) -&gt; None:\n        \"\"\"Set the reference radius for a specific element and update the adjacency list.\n\n        Updates the reference radius for the specified chemical element\n        and recalculates the molecular adjacency list based on the new radius value.\n\n        Args:\n            element (str): Chemical element symbol\n            radius (float): New radius value in Angstroms\n\n        Examples:\n            &gt;&gt;&gt; mg.set_element_radius('C', 0.75)\n        \"\"\"\n        self.default_radii[element] = radius\n        if element in self.elements:\n            self.atomic_radii = [self.default_radii[element] for element in self.elements]\n            self._generate_adjacency_list()\n\n    def set_element_color(self, element: str, color: str) -&gt; None:\n        \"\"\"Set the CPK color for a specific element.\n\n        Assigns a custom CPK (Corey-Pauling-Koltun) color to the specified chemical element\n        for use in molecular visualizations.\n\n        Args:\n            element (str): Chemical element symbol\n            color (str): Color name or code (any format accepted by Plotly)\n\n        Examples:\n            &gt;&gt;&gt; mg.set_element_color('O', 'green')\n            &gt;&gt;&gt; mg.set_element_color('C', '#00FF00')\n        \"\"\"\n        self.cpk_colors[element] = color\n\n    def set_default_color(self, color: str) -&gt; None:\n        \"\"\"Set the default color for elements not in the standard CPK color scheme.\n\n        Specifies the fallback color to use for any chemical elements\n        that don't have a standard CPK color assignment.\n\n        Args:\n            color (str): Color name or code (any format accepted by Plotly)\n\n        Examples:\n            &gt;&gt;&gt; mg.set_default_color('gray')\n            &gt;&gt;&gt; mg.set_default_color('#A0A0A0')\n        \"\"\"\n        self.cpk_color_rest = color\n\n    def filter(\n        self,\n        indices: Optional[List[int]] = None,\n        elements: Optional[List[str]] = None,\n        inplace: bool = False,\n    ) -&gt; Optional[\"MolGraph\"]:\n        \"\"\"Filter out atoms by indices and/or elements.\n\n        Filter atoms from the molecular structure based on their indices or element types.\n        Can either modify the existing structure or create a new filtered copy.\n\n        Args:\n            indices (List[int], optional): List of atom indices to filter out.\n                If None, no indices are removed.\n            elements (List[str], optional): List of element symbols to filter out.\n                If None, no elements are removed.\n            inplace (bool, default=False): If True, modifies the current object.\n                If False, returns a new object.\n\n        Returns:\n            Optional[MolGraph]: A new filtered MolGraph object if inplace=False,\n                None if inplace=True.\n\n        Raises:\n            ValueError: If filtering would remove all atoms.\n            IndexError: If any index is out of range.\n\n        Examples:\n            &gt;&gt;&gt; mg_without_h = mg.filter(elements=['H']) # Filter out all hydrogen atoms\n            &gt;&gt;&gt; mg_trimmed = mg.filter(indices=[0, 1, 2]) # Filter out specific atoms by index\n            &gt;&gt;&gt; mg_modified = mg.filter(indices=[0, 1, 2], elements=['H'])\n            &gt;&gt;&gt; mg.filter(elements=['H'], inplace=True) # Modify in place\n        \"\"\"\n        from itertools import compress, starmap\n        from operator import and_\n\n        # Create mask for all atoms (True means keep)\n        mask = [True] * len(self)\n\n        # Apply indices filter if specified\n        if indices is not None:\n            # Validate indices\n            if any(i &lt; 0 or i &gt;= len(self) for i in indices):\n                raise IndexError(\"Atom index out of range\")\n            for idx in indices:\n                mask[idx] = False\n\n        # Apply elements filter if specified\n        if elements is not None:\n            # Track which filter elements are actually used\n            found_elements = set()\n            for elem in self.elements:\n                if elem in elements:\n                    found_elements.add(elem)\n\n            # Warn about unused filter elements\n            unused_elements = set(elements) - found_elements\n            if unused_elements:\n                logger.warning(\n                    f\"Element(s) not found: {', '.join(sorted(unused_elements))}. \"\n                    \"Use proper case (e.g., 'H' not 'h')\"\n                )\n\n        # Update mask to remove specified elements\n        element_mask = [elem not in (elements or []) for elem in self.elements]\n        mask = list(starmap(and_, zip(mask, element_mask)))\n\n        # Check if any atoms remain\n        if not any(mask):\n            raise ValueError(\"Cannot filter out all atoms from molecule\")\n\n        # If modifying in place\n        if inplace:\n            # Store filtered data using compress\n            self.elements = list(compress(self.elements, mask))\n            self.x = list(compress(self.x, mask))\n            self.y = list(compress(self.y, mask))\n            self.z = list(compress(self.z, mask))\n            self.atomic_radii = list(compress(self.atomic_radii, mask))\n            self.indices = list(compress(self.indices, mask))\n\n            # Regenerate adjacency information\n            self._generate_adjacency_list()\n            return None\n\n        # Create new instance\n        new_mg = MolGraph()\n        new_mg.elements = list(compress(self.elements, mask))\n        new_mg.x = list(compress(self.x, mask))\n        new_mg.y = list(compress(self.y, mask))\n        new_mg.z = list(compress(self.z, mask))\n        new_mg.atomic_radii = list(compress(self.atomic_radii, mask))\n        new_mg.indices = list(compress(self.indices, mask))\n        new_mg.comment = self.comment\n\n        # Copy customization settings\n        new_mg.default_radii = self.default_radii.copy()\n        new_mg.cpk_colors = self.cpk_colors.copy()\n        new_mg.cpk_color_rest = self.cpk_color_rest\n\n        # Generate adjacency information for new molecule\n        new_mg._generate_adjacency_list()\n        return new_mg\n\n    def _parse_coordinates(\n        self, data: Sequence[str]\n    ) -&gt; Tuple[List[str], List[float], List[float], List[float]]:\n        \"\"\"Parse atomic coordinates from a coordinate string list.\n\n        Takes a list of coordinate strings in 'element x y z' format and parses them into\n        separate lists of elements and their corresponding x, y, z coordinates. Each coordinate\n        string should contain an element symbol followed by three space-separated numeric values\n        representing the atomic position in 3D space.\n\n        Args:\n            data (Sequence[str]): List of coordinate strings, where each string contains an\n            element symbol and coordinates in the format 'element x y z' (e.g., 'H 0.0 0.0 0.0').\n\n        Returns:\n            Tuple[List[str], List[float], List[float], List[float]]: A tuple containing four lists:\n            elements, x_coordinates, y_coordinates, and z_coordinates.\n\n        Raises:\n            ValueError: If any coordinate string has invalid format or contains unknown element\n            symbols not present in the default radii dictionary.\n\n        Examples:\n            &gt;&gt;&gt; mg = MolGraph()\n            &gt;&gt;&gt; coords = ['H 0.0 0.0 0.0', 'O 0.0 0.0 1.0']\n            &gt;&gt;&gt; elements, x, y, z = mg._parse_coordinates(coords)\n            &gt;&gt;&gt; print(elements)\n            ['H', 'O']\n            &gt;&gt;&gt; print(x)\n            [0.0, 0.0]\n        \"\"\"\n        elements, xs, ys, zs = [], [], [], []\n\n        pattern = re.compile(\n            r\"^([a-z]{1,3})\\s+\"  # Element symbol (1-3 letters)\n            r\"(-?\\d+\\.?\\d*)\\s+\"  # x coordinate (integer or float)\n            r\"(-?\\d+\\.?\\d*)\\s+\"  # y coordinate (integer or float)\n            r\"(-?\\d+\\.?\\d*)$\",  # z coordinate (integer or float)\n            re.IGNORECASE,\n        )\n\n        for string in data:\n            if not (string := string.strip()):\n                continue\n\n            if not (match := pattern.match(string)):\n                logger.error(f\"Invalid coordinate format: {string}\")\n                raise ValueError(f\"Invalid coordinate format: {string}\")\n\n            element, x, y, z = match.groups()\n            if element not in self.default_radii:\n                logger.error(f\"Unknown element found: {element}\")\n                raise ValueError(f\"Unknown element found: {element}\")\n\n            elements.append(element)\n            xs.append(float(x))\n            ys.append(float(y))\n            zs.append(float(z))\n\n        if not elements:\n            logger.error(\"No valid coordinates found\")\n            raise ValueError(\"No valid coordinates found\")\n\n        return elements, xs, ys, zs\n\n    def read_xyz(\n        self, file_path: Union[str, Path], xyz_start: int = 2, validate: bool = False\n    ) -&gt; None:\n        \"\"\"Reads molecular structure data from an XYZ file.\n\n        The file should have a header with the number of atoms and optional comment, followed by\n        atomic coordinates in Angstroms with element symbols.\n\n        Args:\n            file_path (Union[str, Path]): Path to the XYZ file\n            xyz_start (int, optional): Line number where XYZ coordinate data starts. Defaults to 2.\n            validate (bool, optional, default=False): If True, validates that the number\n                of coordinates matches the atom count in the first line. Note: validation is\n                automatically disabled if xyz_start=0. Defaults to False.\n\n        Raises:\n            FileNotFoundError: If the specified file does not exist\n            ValueError: If the file format is invalid or contains unknown elements\n\n        Notes:\n            The XYZ file format is a standard chemical file format that contains:\n\n                - First line: Number of atoms\n                - Second line: Comment or molecule name (optional)\n                - Remaining lines: Atomic coordinates in format \"element x y z\"\n\n            The function supports both standard XYZ files (xyz_start=2) and raw coordinate data\n            (xyz_start=0). When validation is enabled, it checks that the number of coordinates\n            matches the atom count specified in the first line.\n\n        Examples:\n            &gt;&gt;&gt; mg = MolGraph()\n            &gt;&gt;&gt; mg.read_xyz(\"molecule.xyz\")  # Read standard XYZ file (starts at line 2)\n            &gt;&gt;&gt; mg.read_xyz(\"coords.xyz\", xyz_start=0)  # Read XYZ data starting from first line\n            &gt;&gt;&gt; mg.read_xyz(\"molecule.xyz\", validate=True)  # Enable validation of atom count\n        \"\"\"\n        logger.debug(f\"Reading XYZ file: {file_path}\")\n\n        # Handle validation conflict\n        if validate and xyz_start &lt; 1:\n            logger.warning(\n                \"Atom count validation disabled:\"\n                \" cannot validate when reading from first line \"\n                \"(xyz_start=0)\"\n            )\n            validate = False\n\n        file_path = Path(file_path)\n        if not file_path.exists():\n            logger.error(f\"XYZ file not found: {file_path}\")\n            raise FileNotFoundError(f\"XYZ file not found: {file_path}\")\n\n        try:\n            lines = file_path.read_text().strip().split(\"\\n\")\n            if len(lines) &lt;= xyz_start:\n                logger.error(f\"XYZ file has no coordinate data after line {xyz_start}\")\n                raise ValueError(f\"XYZ file has no coordinate data after line {xyz_start}\")\n\n            # Get expected atom count if validation is requested\n            expected_atoms = None\n            if validate:\n                try:\n                    expected_atoms = int(lines[0])\n                    logger.debug(f\"Expected number of atoms: {expected_atoms}\")\n                except (IndexError, ValueError) as err:\n                    logger.error(\"Could not read atom count from first line\")\n                    raise ValueError(\"Could not read atom count from first line\") from err\n\n            # Store comment if available (line 1 in standard XYZ format)\n            if xyz_start &gt; 1:\n                self.comment = lines[1].strip()\n                logger.debug(f\"Read comment: {self.comment}\")\n\n            coordinates = self._parse_coordinates(lines[xyz_start:])\n            self.elements, self.x, self.y, self.z = coordinates\n\n            # Validate number of atoms if requested\n            if validate and len(self.elements) != expected_atoms:\n                logger.error(\n                    f\"Number of coordinates doesn't match atom count in first line. \"\n                    f\"Expected: {expected_atoms}, Found: {len(self.elements)}\"\n                )\n                raise ValueError(\n                    f\"Number of coordinates doesn't match atom count in first line. \"\n                    f\"Expected: {expected_atoms}, Found: {len(self.elements)}\"\n                )\n\n            logger.info(f\"Successfully read {len(self.elements)} atoms from {file_path}\")\n\n            self.atomic_radii = [self.default_radii[element] for element in self.elements]\n            self._generate_adjacency_list()\n\n            # Store only essential geometric and reference data\n            self._original_state = {\n                \"elements\": self.elements.copy(),\n                \"x\": self.x.copy(),\n                \"y\": self.y.copy(),\n                \"z\": self.z.copy(),\n                \"indices\": self.indices.copy(),\n            }\n\n        except Exception as e:\n            logger.error(f\"Error reading XYZ file: {e}\", exc_info=True)\n            raise\n\n    def _create_atom_trace(self, plot_config: PlotConfig) -&gt; go.Scatter3d:\n        \"\"\"Creates a Plotly trace for atoms in the molecule.\"\"\"\n        colors = [self.cpk_colors.get(element, self.cpk_color_rest) for element in self.elements]\n\n        hover_text = [\n            f\"{i}. {elem} ({x:.2f}, {y:.2f}, {z:.2f})\"\n            for i, (elem, x, y, z) in enumerate(zip(self.elements, self.x, self.y, self.z))\n        ]\n\n        return go.Scatter3d(\n            x=self.x,\n            y=self.y,\n            z=self.z,\n            mode=\"markers\",\n            marker=dict(\n                color=colors,\n                line=dict(\n                    color=plot_config[\"atom_border_color\"],\n                    width=plot_config[\"atom_border_width\"],\n                ),\n                size=plot_config[\"atom_size\"],\n                opacity=plot_config[\"atom_opacity\"],\n                symbol=\"circle\",\n            ),\n            text=self.elements,\n            hovertext=hover_text,\n            hoverinfo=\"text\",\n            name=\"atoms\",\n        )\n\n    def _create_bond_trace(self, plot_config: PlotConfig) -&gt; go.Scatter3d:\n        \"\"\"Creates a Plotly trace for bonds in the molecule.\"\"\"\n        # Create line segments for each bond (use None to separate segments)\n        xs, ys, zs = [], [], []\n        for i, j in self.edges():\n            xs.extend([self.x[i], self.x[j], None])\n            ys.extend([self.y[i], self.y[j], None])\n            zs.extend([self.z[i], self.z[j], None])\n\n        return go.Scatter3d(\n            x=xs,\n            y=ys,\n            z=zs,\n            mode=\"lines\",\n            line=dict(color=plot_config[\"bond_color\"], width=plot_config[\"bond_width\"]),\n            hoverinfo=\"none\",\n            name=\"bonds\",\n        )\n\n    def _create_annotations(\n        self,\n        plot_config: PlotConfig,\n        atom_label_type: Optional[str] = None,\n        show_distances: bool = False,\n    ) -&gt; List[dict]:\n        \"\"\"Create annotations for atom and bond labels in the molecular plot.\n\n        Creates Plotly annotation dictionaries for displaying atom labels (either element\n        symbols or indices) and/or bond length labels. The annotations are positioned above\n        each atom or bond with configurable vertical offset.\n\n        Args:\n            plot_config (PlotConfig): Plot configuration dictionary containing visual\n                parameters like label offsets and colors.\n            atom_label_type (Optional[str]): Type of atom labels to show. Must be one of:\n                None, \"element\", or \"index\". None means no atom labels.\n            show_distances (bool): Whether to show bond length labels centered on each bond.\n\n        Returns:\n            List[dict]: List of Plotly annotation dictionaries containing text, position,\n                and style information for atom and bond labels.\n\n        Raises:\n            ValueError: If atom_label_type is not one of: None, \"element\", or \"index\".\n        \"\"\"\n        labels = []\n\n        if atom_label_type is not None:\n            if atom_label_type not in (\"element\", \"index\"):\n                raise ValueError('atom_label_type must be None, \"element\", or \"index\"')\n\n            for idx, (element, (x, y, z)) in enumerate(self):\n                text = element if atom_label_type == \"element\" else str(idx)\n                labels.append(\n                    dict(\n                        text=text,\n                        x=x,\n                        y=y,\n                        z=z,\n                        showarrow=False,\n                        yshift=plot_config[\"label_offset\"],\n                    )\n                )\n\n        if show_distances:\n            for (i, j), length in self.bond_lengths.items():\n                labels.append(\n                    dict(\n                        text=f\"{length:.2f}\",\n                        x=(self.x[i] + self.x[j]) / 2,\n                        y=(self.y[i] + self.y[j]) / 2,\n                        z=(self.z[i] + self.z[j]) / 2,\n                        showarrow=False,\n                        yshift=plot_config[\"label_offset\"],\n                        font=dict(color=plot_config[\"bond_label_color\"]),\n                    )\n                )\n\n        return labels\n\n    def _create_menu_buttons(self, plot_config: PlotConfig) -&gt; List[dict]:\n        \"\"\"Creates menu buttons for toggling different label displays.\"\"\"\n        return [\n            dict(\n                label=\"Elements\",\n                method=\"relayout\",\n                args=[\n                    {\n                        \"scene.annotations\": self._create_annotations(\n                            plot_config, atom_label_type=\"element\"\n                        )\n                    }\n                ],\n            ),\n            dict(\n                label=\"Elements &amp; Distances\",\n                method=\"relayout\",\n                args=[\n                    {\n                        \"scene.annotations\": self._create_annotations(\n                            plot_config,\n                            atom_label_type=\"element\",\n                            show_distances=True,\n                        )\n                    }\n                ],\n            ),\n            dict(\n                label=\"IDs\",\n                method=\"relayout\",\n                args=[\n                    {\n                        \"scene.annotations\": self._create_annotations(\n                            plot_config, atom_label_type=\"index\"\n                        )\n                    }\n                ],\n            ),\n            dict(\n                label=\"IDs &amp; Distances\",\n                method=\"relayout\",\n                args=[\n                    {\n                        \"scene.annotations\": self._create_annotations(\n                            plot_config, atom_label_type=\"index\", show_distances=True\n                        )\n                    }\n                ],\n            ),\n            dict(\n                label=\"Distances\",\n                method=\"relayout\",\n                args=[\n                    {\n                        \"scene.annotations\": self._create_annotations(\n                            plot_config, show_distances=True\n                        )\n                    }\n                ],\n            ),\n            dict(label=\"Clear\", method=\"relayout\", args=[{\"scene.annotations\": []}]),\n        ]\n\n    def to_plotly(\n        self,\n        config: Optional[PlotConfig] = None,\n        title: Optional[str] = None,\n    ) -&gt; go.Figure:\n        \"\"\"Creates an interactive 3D visualization of the molecular structure.\n\n        Generates a Plotly figure displaying atoms as spheres and bonds as lines, with\n        configurable visual properties and interactive features for exploring the molecule's\n        geometry.\n\n        Args:\n            config (Optional[PlotConfig]): Dictionary of visualization settings:\n\n                - atom_size (int): Size of atom markers (default: 7)\n                - atom_opacity (float): Opacity of atoms from 0.0-1.0 (default: 0.8)\n                - atom_border_color (str): Color of atom borders (default: \"lightgray\")\n                - atom_border_width (int): Width of atom borders (default: 2)\n                - bond_color (str): Color of bonds between atoms (default: \"grey\")\n                - bond_width (int): Width of bond lines (default: 2)\n                - show_grid (bool): Whether to display axis grid (default: False)\n                - label_offset (int): Vertical offset for labels (default: 15)\n                - bond_label_color (str): Color of bond length labels (default: \"steelblue\")\n\n            title (Optional[str]): Title displayed above visualization (default: None)\n\n        Returns:\n            go.Figure: Plotly figure object containing:\n\n                - 3D scatter plot of atoms colored by element\n                - Line segments representing bonds\n                - Interactive menu for toggling labels:\n\n                    - Element symbols\n                    - Atom indices\n                    - Bond lengths\n                    - Combinations of the above\n\n                - Mouse controls for rotation, zoom, and pan\n\n        Examples:\n            &gt;&gt;&gt; fig = mg.to_plotly(config={\n            ...     \"atom_size\": 12,\n            ...     \"atom_opacity\": 0.9,\n            ...     \"bond_color\": \"black\",\n            ...     \"show_grid\": True,\n            ...     \"label_offset\": 20\n            ... })\n            &gt;&gt;&gt; fig.show()\n        \"\"\"\n        logger.debug(\"Creating Plotly figure\")\n\n        if not self.elements:\n            logger.warning(\"No molecular data to visualize\")\n            return go.Figure()\n\n        plot_config = DEFAULT_PLOT_CONFIG.copy()\n        if config:\n            plot_config.update(config)\n\n        # Create figure\n        data = [\n            self._create_atom_trace(plot_config),\n            self._create_bond_trace(plot_config),\n        ]\n\n        # Configure axis parameters\n        axis_params = dict(\n            showgrid=plot_config[\"show_grid\"],\n            showbackground=False,\n            showticklabels=False,\n            zeroline=False,\n            titlefont=dict(color=\"white\"),\n            showspikes=False,\n        )\n\n        # Build layout\n        layout = dict(\n            title=title,\n            scene=dict(\n                xaxis=axis_params,\n                yaxis=axis_params,\n                zaxis=axis_params,\n                annotations=self._create_annotations(plot_config, atom_label_type=\"element\"),\n            ),\n            margin=dict(r=0, l=0, b=0, t=0 if not title else 40),\n            showlegend=False,\n            updatemenus=[\n                dict(\n                    buttons=self._create_menu_buttons(plot_config),\n                    direction=\"down\",\n                    xanchor=\"left\",\n                    yanchor=\"top\",\n                    pad=dict(r=10, t=10),\n                )\n            ],\n        )\n\n        logger.debug(\"Plotly figure created successfully\")\n        return go.Figure(data=data, layout=layout)\n\n    def to_networkx(self) -&gt; nx.Graph:\n        \"\"\"Convert the current graph representation to a NetworkX graph.\n\n        Creates a NetworkX graph from the stored adjacency list, adding node and edge attributes.\n        Node attributes include the chemical element and xyz coordinates, while edge attributes\n        store bond lengths.\n\n        Returns:\n            nx.Graph: NetworkX graph containing molecular structure with node attributes 'element'\n                and 'xyz' (coordinates), and edge attribute 'length' (bond length).\n\n        Examples:\n            &gt;&gt;&gt; mg = MolGraph()\n            &gt;&gt;&gt; mg.read_xyz('molecule.xyz')\n            &gt;&gt;&gt; G = mg.to_networkx()\n            &gt;&gt;&gt; print(G.nodes[0]['element'])\n            'C'\n            &gt;&gt;&gt; print(G.edges[(0, 1)]['length'])\n            1.54\n        \"\"\"\n        logger.debug(\"Creating NetworkX graph\")\n\n        G = nx.Graph(self.adj_list)\n\n        # Add node attributes\n        node_attrs = {\n            num: {\"element\": element, \"xyz\": (self.x[num], self.y[num], self.z[num])}\n            for num, element in enumerate(self.elements)\n        }\n        nx.set_node_attributes(G, node_attrs)\n\n        # Add edge attributes\n        edge_attrs = {edge: {\"length\": length} for edge, length in self.bond_lengths.items()}\n        nx.set_edge_attributes(G, edge_attrs)\n        logger.debug(\"NetworkX graph created successfully\")\n\n        return G\n\n    def _generate_adjacency_list(self) -&gt; None:\n        \"\"\"Generates the adjacency list and matrix based on atomic positions and radii.\n\n        This method uses atomic positions and reference radii to determine bonding\n        between atoms. Two atoms are considered bonded if their distance is less\n        than 1.3 times the sum of their atomic radii.\n        \"\"\"\n        logger.debug(\"Generating adjacency list\")\n\n        try:\n            xyz = np.stack((self.x, self.y, self.z), axis=-1)\n            distances = xyz[:, np.newaxis, :] - xyz\n            distances = np.sqrt(np.einsum(\"ijk,ijk-&gt;ij\", distances, distances))\n\n            atomic_radii = np.array(self.atomic_radii)\n            distance_bond = (atomic_radii[:, np.newaxis] + atomic_radii) * 1.3\n\n            self.adj_matrix = np.logical_and(0.1 &lt; distances, distance_bond &gt; distances).astype(int)\n\n            # Clear existing adjacency data\n            self.adj_list.clear()\n            self.bond_lengths.clear()\n\n            # Generate new adjacency data\n            for i, j in zip(*np.nonzero(self.adj_matrix)):\n                self.adj_list.setdefault(i, set()).add(j)\n                self.adj_list.setdefault(j, set()).add(i)\n                self.bond_lengths[frozenset([i, j])] = round(distances[i, j], 5)\n            logger.debug(\"Adjacency list generated successfully\")\n\n        except Exception as e:\n            logger.error(f\"Error generating adjacency list: {e}\", exc_info=True)\n            raise\n\n    def edges(self) -&gt; Iterator[Tuple[int, int]]:\n        \"\"\"Create an iterator yielding all bonds in the molecular graph.\n\n        Iterates through the adjacency list to generate all unique pairs of bonded atoms\n        in the structure, ensuring each bond is only yielded once.\n\n        Yields:\n            tuple[int, int]: A pair of atom indices representing a bonded atomic pair,\n                where each index corresponds to the atom's position in the molecular structure.\n\n        Examples:\n            &gt;&gt;&gt; mg = MolGraph()\n            &gt;&gt;&gt; mg.read_xyz('molecule.xyz')\n            &gt;&gt;&gt; for atom1, atom2 in mg.edges():\n            ...     print(f\"Bond between atoms {atom1} and {atom2}\")\n            Bond between atoms 0 and 1\n            Bond between atoms 1 and 2\n        \"\"\"\n        edges = set()\n        for node, neighbours in self.adj_list.items():\n            for neighbour in neighbours:\n                bond = frozenset([node, neighbour])\n                if bond in edges:\n                    continue\n                edges.add(bond)\n                yield node, neighbour\n\n    def formula(self) -&gt; str:\n        \"\"\"Return the molecular formula of the structure in Hill notation.\n\n        Generates a string representation of the molecular formula following Hill\n        notation conventions, where carbon and hydrogen (if present) are listed first,\n        followed by other elements in alphabetical order. Numbers are added as\n        subscripts for elements appearing multiple times.\n\n        Returns:\n            str: The molecular formula string with elements ordered by Hill notation\n                (e.g., 'C2H6O' for ethanol).\n\n        Examples:\n            &gt;&gt;&gt; mg = MolGraph()\n            &gt;&gt;&gt; mg.read_xyz('ethanol.xyz')\n            &gt;&gt;&gt; print(mg.formula())\n            'C2H6O'\n        \"\"\"\n        if not self.elements:\n            return \"\"\n\n        element_counts = Counter(self.elements)\n\n        # Build formula in Hill notation\n        formula_parts = []\n\n        # Carbon and Hydrogen first if carbon is present\n        if \"C\" in element_counts:\n            count = element_counts.pop(\"C\")\n            formula_parts.append(f\"C{count if count &gt; 1 else ''}\")\n\n            if \"H\" in element_counts:\n                count = element_counts.pop(\"H\")\n                formula_parts.append(f\"H{count if count &gt; 1 else ''}\")\n\n        # Add remaining elements alphabetically\n        for element in sorted(element_counts):\n            count = element_counts[element]\n            formula_parts.append(f\"{element}{count if count &gt; 1 else ''}\")\n\n        return \"\".join(formula_parts)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Returns the number of atoms in the molecule.\n\n        Returns:\n            int: Number of atoms\n        \"\"\"\n        return len(self.elements)\n\n    def __getitem__(self, position: int) -&gt; Tuple[str, Tuple[float, float, float]]:\n        \"\"\"Returns the element and coordinates for the atom at the given position.\n\n        Args:\n            position: Index of the atom\n\n        Returns:\n            Tuple[str, Tuple[float, float, float]]: Tuple containing the element\n            symbol and its (x, y, z) coordinates\n\n        Raises:\n            IndexError: If position is out of range\n        \"\"\"\n        if not 0 &lt;= position &lt; len(self):\n            raise IndexError(\"Atom index out of range\")\n\n        return self.elements[position], (\n            self.x[position],\n            self.y[position],\n            self.z[position],\n        )\n\n    def __iter__(self) -&gt; Iterator[Tuple[str, Tuple[float, float, float]]]:\n        \"\"\"Creates an iterator over all atoms in the molecule.\n\n        Returns:\n            Iterator[Tuple[str, Tuple[float, float, float]]]: Iterator yielding\n            tuples of (element, coordinates) for each atom\n        \"\"\"\n        return (self[i] for i in range(len(self)))\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Creates a simplified string representation of the molecular graph.\n\n        Returns:\n            str: A string showing molecular formula and basic structural information\n        \"\"\"\n        if not self.elements:\n            return \"MolGraph(empty)\"\n\n        element_counts = Counter(self.elements)\n\n        # Build formula prioritizing C and H\n        formula_parts = []\n        for element in [\"C\", \"H\"]:\n            if count := element_counts.pop(element, 0):\n                formula_parts.append(f\"{element}{count if count &gt; 1 else ''}\")\n\n        # Add remaining elements alphabetically\n        for element in sorted(element_counts):\n            count = element_counts[element]\n            formula_parts.append(f\"{element}{count if count &gt; 1 else ''}\")\n\n        formula = \"\".join(formula_parts)\n        num_bonds = sum(len(neighbors) for neighbors in self.adj_list.values()) // 2\n\n        return f\"MolGraph({formula}: {len(self.elements)} atoms, {num_bonds} bonds)\"\n</code></pre>"},{"location":"python/#xyz2graph.xyz2graph.MolGraph.edges","title":"<code>edges()</code>","text":"<p>Create an iterator yielding all bonds in the molecular graph.</p> <p>Iterates through the adjacency list to generate all unique pairs of bonded atoms in the structure, ensuring each bond is only yielded once.</p> <p>Yields:</p> Type Description <code>Tuple[int, int]</code> <p>tuple[int, int]: A pair of atom indices representing a bonded atomic pair, where each index corresponds to the atom's position in the molecular structure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mg = MolGraph()\n&gt;&gt;&gt; mg.read_xyz('molecule.xyz')\n&gt;&gt;&gt; for atom1, atom2 in mg.edges():\n...     print(f\"Bond between atoms {atom1} and {atom2}\")\nBond between atoms 0 and 1\nBond between atoms 1 and 2\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>def edges(self) -&gt; Iterator[Tuple[int, int]]:\n    \"\"\"Create an iterator yielding all bonds in the molecular graph.\n\n    Iterates through the adjacency list to generate all unique pairs of bonded atoms\n    in the structure, ensuring each bond is only yielded once.\n\n    Yields:\n        tuple[int, int]: A pair of atom indices representing a bonded atomic pair,\n            where each index corresponds to the atom's position in the molecular structure.\n\n    Examples:\n        &gt;&gt;&gt; mg = MolGraph()\n        &gt;&gt;&gt; mg.read_xyz('molecule.xyz')\n        &gt;&gt;&gt; for atom1, atom2 in mg.edges():\n        ...     print(f\"Bond between atoms {atom1} and {atom2}\")\n        Bond between atoms 0 and 1\n        Bond between atoms 1 and 2\n    \"\"\"\n    edges = set()\n    for node, neighbours in self.adj_list.items():\n        for neighbour in neighbours:\n            bond = frozenset([node, neighbour])\n            if bond in edges:\n                continue\n            edges.add(bond)\n            yield node, neighbour\n</code></pre>"},{"location":"python/#xyz2graph.xyz2graph.MolGraph.filter","title":"<code>filter(indices=None, elements=None, inplace=False)</code>","text":"<p>Filter out atoms by indices and/or elements.</p> <p>Filter atoms from the molecular structure based on their indices or element types. Can either modify the existing structure or create a new filtered copy.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>List[int]</code> <p>List of atom indices to filter out. If None, no indices are removed.</p> <code>None</code> <code>elements</code> <code>List[str]</code> <p>List of element symbols to filter out. If None, no elements are removed.</p> <code>None</code> <code>inplace</code> <code>bool, default=False</code> <p>If True, modifies the current object. If False, returns a new object.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[MolGraph]</code> <p>Optional[MolGraph]: A new filtered MolGraph object if inplace=False, None if inplace=True.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If filtering would remove all atoms.</p> <code>IndexError</code> <p>If any index is out of range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mg_without_h = mg.filter(elements=['H']) # Filter out all hydrogen atoms\n&gt;&gt;&gt; mg_trimmed = mg.filter(indices=[0, 1, 2]) # Filter out specific atoms by index\n&gt;&gt;&gt; mg_modified = mg.filter(indices=[0, 1, 2], elements=['H'])\n&gt;&gt;&gt; mg.filter(elements=['H'], inplace=True) # Modify in place\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>def filter(\n    self,\n    indices: Optional[List[int]] = None,\n    elements: Optional[List[str]] = None,\n    inplace: bool = False,\n) -&gt; Optional[\"MolGraph\"]:\n    \"\"\"Filter out atoms by indices and/or elements.\n\n    Filter atoms from the molecular structure based on their indices or element types.\n    Can either modify the existing structure or create a new filtered copy.\n\n    Args:\n        indices (List[int], optional): List of atom indices to filter out.\n            If None, no indices are removed.\n        elements (List[str], optional): List of element symbols to filter out.\n            If None, no elements are removed.\n        inplace (bool, default=False): If True, modifies the current object.\n            If False, returns a new object.\n\n    Returns:\n        Optional[MolGraph]: A new filtered MolGraph object if inplace=False,\n            None if inplace=True.\n\n    Raises:\n        ValueError: If filtering would remove all atoms.\n        IndexError: If any index is out of range.\n\n    Examples:\n        &gt;&gt;&gt; mg_without_h = mg.filter(elements=['H']) # Filter out all hydrogen atoms\n        &gt;&gt;&gt; mg_trimmed = mg.filter(indices=[0, 1, 2]) # Filter out specific atoms by index\n        &gt;&gt;&gt; mg_modified = mg.filter(indices=[0, 1, 2], elements=['H'])\n        &gt;&gt;&gt; mg.filter(elements=['H'], inplace=True) # Modify in place\n    \"\"\"\n    from itertools import compress, starmap\n    from operator import and_\n\n    # Create mask for all atoms (True means keep)\n    mask = [True] * len(self)\n\n    # Apply indices filter if specified\n    if indices is not None:\n        # Validate indices\n        if any(i &lt; 0 or i &gt;= len(self) for i in indices):\n            raise IndexError(\"Atom index out of range\")\n        for idx in indices:\n            mask[idx] = False\n\n    # Apply elements filter if specified\n    if elements is not None:\n        # Track which filter elements are actually used\n        found_elements = set()\n        for elem in self.elements:\n            if elem in elements:\n                found_elements.add(elem)\n\n        # Warn about unused filter elements\n        unused_elements = set(elements) - found_elements\n        if unused_elements:\n            logger.warning(\n                f\"Element(s) not found: {', '.join(sorted(unused_elements))}. \"\n                \"Use proper case (e.g., 'H' not 'h')\"\n            )\n\n    # Update mask to remove specified elements\n    element_mask = [elem not in (elements or []) for elem in self.elements]\n    mask = list(starmap(and_, zip(mask, element_mask)))\n\n    # Check if any atoms remain\n    if not any(mask):\n        raise ValueError(\"Cannot filter out all atoms from molecule\")\n\n    # If modifying in place\n    if inplace:\n        # Store filtered data using compress\n        self.elements = list(compress(self.elements, mask))\n        self.x = list(compress(self.x, mask))\n        self.y = list(compress(self.y, mask))\n        self.z = list(compress(self.z, mask))\n        self.atomic_radii = list(compress(self.atomic_radii, mask))\n        self.indices = list(compress(self.indices, mask))\n\n        # Regenerate adjacency information\n        self._generate_adjacency_list()\n        return None\n\n    # Create new instance\n    new_mg = MolGraph()\n    new_mg.elements = list(compress(self.elements, mask))\n    new_mg.x = list(compress(self.x, mask))\n    new_mg.y = list(compress(self.y, mask))\n    new_mg.z = list(compress(self.z, mask))\n    new_mg.atomic_radii = list(compress(self.atomic_radii, mask))\n    new_mg.indices = list(compress(self.indices, mask))\n    new_mg.comment = self.comment\n\n    # Copy customization settings\n    new_mg.default_radii = self.default_radii.copy()\n    new_mg.cpk_colors = self.cpk_colors.copy()\n    new_mg.cpk_color_rest = self.cpk_color_rest\n\n    # Generate adjacency information for new molecule\n    new_mg._generate_adjacency_list()\n    return new_mg\n</code></pre>"},{"location":"python/#xyz2graph.xyz2graph.MolGraph.formula","title":"<code>formula()</code>","text":"<p>Return the molecular formula of the structure in Hill notation.</p> <p>Generates a string representation of the molecular formula following Hill notation conventions, where carbon and hydrogen (if present) are listed first, followed by other elements in alphabetical order. Numbers are added as subscripts for elements appearing multiple times.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The molecular formula string with elements ordered by Hill notation (e.g., 'C2H6O' for ethanol).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mg = MolGraph()\n&gt;&gt;&gt; mg.read_xyz('ethanol.xyz')\n&gt;&gt;&gt; print(mg.formula())\n'C2H6O'\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>def formula(self) -&gt; str:\n    \"\"\"Return the molecular formula of the structure in Hill notation.\n\n    Generates a string representation of the molecular formula following Hill\n    notation conventions, where carbon and hydrogen (if present) are listed first,\n    followed by other elements in alphabetical order. Numbers are added as\n    subscripts for elements appearing multiple times.\n\n    Returns:\n        str: The molecular formula string with elements ordered by Hill notation\n            (e.g., 'C2H6O' for ethanol).\n\n    Examples:\n        &gt;&gt;&gt; mg = MolGraph()\n        &gt;&gt;&gt; mg.read_xyz('ethanol.xyz')\n        &gt;&gt;&gt; print(mg.formula())\n        'C2H6O'\n    \"\"\"\n    if not self.elements:\n        return \"\"\n\n    element_counts = Counter(self.elements)\n\n    # Build formula in Hill notation\n    formula_parts = []\n\n    # Carbon and Hydrogen first if carbon is present\n    if \"C\" in element_counts:\n        count = element_counts.pop(\"C\")\n        formula_parts.append(f\"C{count if count &gt; 1 else ''}\")\n\n        if \"H\" in element_counts:\n            count = element_counts.pop(\"H\")\n            formula_parts.append(f\"H{count if count &gt; 1 else ''}\")\n\n    # Add remaining elements alphabetically\n    for element in sorted(element_counts):\n        count = element_counts[element]\n        formula_parts.append(f\"{element}{count if count &gt; 1 else ''}\")\n\n    return \"\".join(formula_parts)\n</code></pre>"},{"location":"python/#xyz2graph.xyz2graph.MolGraph.read_xyz","title":"<code>read_xyz(file_path, xyz_start=2, validate=False)</code>","text":"<p>Reads molecular structure data from an XYZ file.</p> <p>The file should have a header with the number of atoms and optional comment, followed by atomic coordinates in Angstroms with element symbols.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Union[str, Path]</code> <p>Path to the XYZ file</p> required <code>xyz_start</code> <code>int</code> <p>Line number where XYZ coordinate data starts. Defaults to 2.</p> <code>2</code> <code>validate</code> <code>bool, optional, default=False</code> <p>If True, validates that the number of coordinates matches the atom count in the first line. Note: validation is automatically disabled if xyz_start=0. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified file does not exist</p> <code>ValueError</code> <p>If the file format is invalid or contains unknown elements</p> Notes <p>The XYZ file format is a standard chemical file format that contains:</p> <pre><code>- First line: Number of atoms\n- Second line: Comment or molecule name (optional)\n- Remaining lines: Atomic coordinates in format \"element x y z\"\n</code></pre> <p>The function supports both standard XYZ files (xyz_start=2) and raw coordinate data (xyz_start=0). When validation is enabled, it checks that the number of coordinates matches the atom count specified in the first line.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mg = MolGraph()\n&gt;&gt;&gt; mg.read_xyz(\"molecule.xyz\")  # Read standard XYZ file (starts at line 2)\n&gt;&gt;&gt; mg.read_xyz(\"coords.xyz\", xyz_start=0)  # Read XYZ data starting from first line\n&gt;&gt;&gt; mg.read_xyz(\"molecule.xyz\", validate=True)  # Enable validation of atom count\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>def read_xyz(\n    self, file_path: Union[str, Path], xyz_start: int = 2, validate: bool = False\n) -&gt; None:\n    \"\"\"Reads molecular structure data from an XYZ file.\n\n    The file should have a header with the number of atoms and optional comment, followed by\n    atomic coordinates in Angstroms with element symbols.\n\n    Args:\n        file_path (Union[str, Path]): Path to the XYZ file\n        xyz_start (int, optional): Line number where XYZ coordinate data starts. Defaults to 2.\n        validate (bool, optional, default=False): If True, validates that the number\n            of coordinates matches the atom count in the first line. Note: validation is\n            automatically disabled if xyz_start=0. Defaults to False.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist\n        ValueError: If the file format is invalid or contains unknown elements\n\n    Notes:\n        The XYZ file format is a standard chemical file format that contains:\n\n            - First line: Number of atoms\n            - Second line: Comment or molecule name (optional)\n            - Remaining lines: Atomic coordinates in format \"element x y z\"\n\n        The function supports both standard XYZ files (xyz_start=2) and raw coordinate data\n        (xyz_start=0). When validation is enabled, it checks that the number of coordinates\n        matches the atom count specified in the first line.\n\n    Examples:\n        &gt;&gt;&gt; mg = MolGraph()\n        &gt;&gt;&gt; mg.read_xyz(\"molecule.xyz\")  # Read standard XYZ file (starts at line 2)\n        &gt;&gt;&gt; mg.read_xyz(\"coords.xyz\", xyz_start=0)  # Read XYZ data starting from first line\n        &gt;&gt;&gt; mg.read_xyz(\"molecule.xyz\", validate=True)  # Enable validation of atom count\n    \"\"\"\n    logger.debug(f\"Reading XYZ file: {file_path}\")\n\n    # Handle validation conflict\n    if validate and xyz_start &lt; 1:\n        logger.warning(\n            \"Atom count validation disabled:\"\n            \" cannot validate when reading from first line \"\n            \"(xyz_start=0)\"\n        )\n        validate = False\n\n    file_path = Path(file_path)\n    if not file_path.exists():\n        logger.error(f\"XYZ file not found: {file_path}\")\n        raise FileNotFoundError(f\"XYZ file not found: {file_path}\")\n\n    try:\n        lines = file_path.read_text().strip().split(\"\\n\")\n        if len(lines) &lt;= xyz_start:\n            logger.error(f\"XYZ file has no coordinate data after line {xyz_start}\")\n            raise ValueError(f\"XYZ file has no coordinate data after line {xyz_start}\")\n\n        # Get expected atom count if validation is requested\n        expected_atoms = None\n        if validate:\n            try:\n                expected_atoms = int(lines[0])\n                logger.debug(f\"Expected number of atoms: {expected_atoms}\")\n            except (IndexError, ValueError) as err:\n                logger.error(\"Could not read atom count from first line\")\n                raise ValueError(\"Could not read atom count from first line\") from err\n\n        # Store comment if available (line 1 in standard XYZ format)\n        if xyz_start &gt; 1:\n            self.comment = lines[1].strip()\n            logger.debug(f\"Read comment: {self.comment}\")\n\n        coordinates = self._parse_coordinates(lines[xyz_start:])\n        self.elements, self.x, self.y, self.z = coordinates\n\n        # Validate number of atoms if requested\n        if validate and len(self.elements) != expected_atoms:\n            logger.error(\n                f\"Number of coordinates doesn't match atom count in first line. \"\n                f\"Expected: {expected_atoms}, Found: {len(self.elements)}\"\n            )\n            raise ValueError(\n                f\"Number of coordinates doesn't match atom count in first line. \"\n                f\"Expected: {expected_atoms}, Found: {len(self.elements)}\"\n            )\n\n        logger.info(f\"Successfully read {len(self.elements)} atoms from {file_path}\")\n\n        self.atomic_radii = [self.default_radii[element] for element in self.elements]\n        self._generate_adjacency_list()\n\n        # Store only essential geometric and reference data\n        self._original_state = {\n            \"elements\": self.elements.copy(),\n            \"x\": self.x.copy(),\n            \"y\": self.y.copy(),\n            \"z\": self.z.copy(),\n            \"indices\": self.indices.copy(),\n        }\n\n    except Exception as e:\n        logger.error(f\"Error reading XYZ file: {e}\", exc_info=True)\n        raise\n</code></pre>"},{"location":"python/#xyz2graph.xyz2graph.MolGraph.set_default_color","title":"<code>set_default_color(color)</code>","text":"<p>Set the default color for elements not in the standard CPK color scheme.</p> <p>Specifies the fallback color to use for any chemical elements that don't have a standard CPK color assignment.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Color name or code (any format accepted by Plotly)</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; mg.set_default_color('gray')\n&gt;&gt;&gt; mg.set_default_color('#A0A0A0')\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>def set_default_color(self, color: str) -&gt; None:\n    \"\"\"Set the default color for elements not in the standard CPK color scheme.\n\n    Specifies the fallback color to use for any chemical elements\n    that don't have a standard CPK color assignment.\n\n    Args:\n        color (str): Color name or code (any format accepted by Plotly)\n\n    Examples:\n        &gt;&gt;&gt; mg.set_default_color('gray')\n        &gt;&gt;&gt; mg.set_default_color('#A0A0A0')\n    \"\"\"\n    self.cpk_color_rest = color\n</code></pre>"},{"location":"python/#xyz2graph.xyz2graph.MolGraph.set_element_color","title":"<code>set_element_color(element, color)</code>","text":"<p>Set the CPK color for a specific element.</p> <p>Assigns a custom CPK (Corey-Pauling-Koltun) color to the specified chemical element for use in molecular visualizations.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>Chemical element symbol</p> required <code>color</code> <code>str</code> <p>Color name or code (any format accepted by Plotly)</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; mg.set_element_color('O', 'green')\n&gt;&gt;&gt; mg.set_element_color('C', '#00FF00')\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>def set_element_color(self, element: str, color: str) -&gt; None:\n    \"\"\"Set the CPK color for a specific element.\n\n    Assigns a custom CPK (Corey-Pauling-Koltun) color to the specified chemical element\n    for use in molecular visualizations.\n\n    Args:\n        element (str): Chemical element symbol\n        color (str): Color name or code (any format accepted by Plotly)\n\n    Examples:\n        &gt;&gt;&gt; mg.set_element_color('O', 'green')\n        &gt;&gt;&gt; mg.set_element_color('C', '#00FF00')\n    \"\"\"\n    self.cpk_colors[element] = color\n</code></pre>"},{"location":"python/#xyz2graph.xyz2graph.MolGraph.set_element_radius","title":"<code>set_element_radius(element, radius)</code>","text":"<p>Set the reference radius for a specific element and update the adjacency list.</p> <p>Updates the reference radius for the specified chemical element and recalculates the molecular adjacency list based on the new radius value.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>Chemical element symbol</p> required <code>radius</code> <code>float</code> <p>New radius value in Angstroms</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; mg.set_element_radius('C', 0.75)\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>def set_element_radius(self, element: str, radius: float) -&gt; None:\n    \"\"\"Set the reference radius for a specific element and update the adjacency list.\n\n    Updates the reference radius for the specified chemical element\n    and recalculates the molecular adjacency list based on the new radius value.\n\n    Args:\n        element (str): Chemical element symbol\n        radius (float): New radius value in Angstroms\n\n    Examples:\n        &gt;&gt;&gt; mg.set_element_radius('C', 0.75)\n    \"\"\"\n    self.default_radii[element] = radius\n    if element in self.elements:\n        self.atomic_radii = [self.default_radii[element] for element in self.elements]\n        self._generate_adjacency_list()\n</code></pre>"},{"location":"python/#xyz2graph.xyz2graph.MolGraph.to_networkx","title":"<code>to_networkx()</code>","text":"<p>Convert the current graph representation to a NetworkX graph.</p> <p>Creates a NetworkX graph from the stored adjacency list, adding node and edge attributes. Node attributes include the chemical element and xyz coordinates, while edge attributes store bond lengths.</p> <p>Returns:</p> Type Description <code>Graph</code> <p>nx.Graph: NetworkX graph containing molecular structure with node attributes 'element' and 'xyz' (coordinates), and edge attribute 'length' (bond length).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mg = MolGraph()\n&gt;&gt;&gt; mg.read_xyz('molecule.xyz')\n&gt;&gt;&gt; G = mg.to_networkx()\n&gt;&gt;&gt; print(G.nodes[0]['element'])\n'C'\n&gt;&gt;&gt; print(G.edges[(0, 1)]['length'])\n1.54\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>def to_networkx(self) -&gt; nx.Graph:\n    \"\"\"Convert the current graph representation to a NetworkX graph.\n\n    Creates a NetworkX graph from the stored adjacency list, adding node and edge attributes.\n    Node attributes include the chemical element and xyz coordinates, while edge attributes\n    store bond lengths.\n\n    Returns:\n        nx.Graph: NetworkX graph containing molecular structure with node attributes 'element'\n            and 'xyz' (coordinates), and edge attribute 'length' (bond length).\n\n    Examples:\n        &gt;&gt;&gt; mg = MolGraph()\n        &gt;&gt;&gt; mg.read_xyz('molecule.xyz')\n        &gt;&gt;&gt; G = mg.to_networkx()\n        &gt;&gt;&gt; print(G.nodes[0]['element'])\n        'C'\n        &gt;&gt;&gt; print(G.edges[(0, 1)]['length'])\n        1.54\n    \"\"\"\n    logger.debug(\"Creating NetworkX graph\")\n\n    G = nx.Graph(self.adj_list)\n\n    # Add node attributes\n    node_attrs = {\n        num: {\"element\": element, \"xyz\": (self.x[num], self.y[num], self.z[num])}\n        for num, element in enumerate(self.elements)\n    }\n    nx.set_node_attributes(G, node_attrs)\n\n    # Add edge attributes\n    edge_attrs = {edge: {\"length\": length} for edge, length in self.bond_lengths.items()}\n    nx.set_edge_attributes(G, edge_attrs)\n    logger.debug(\"NetworkX graph created successfully\")\n\n    return G\n</code></pre>"},{"location":"python/#xyz2graph.xyz2graph.MolGraph.to_plotly","title":"<code>to_plotly(config=None, title=None)</code>","text":"<p>Creates an interactive 3D visualization of the molecular structure.</p> <p>Generates a Plotly figure displaying atoms as spheres and bonds as lines, with configurable visual properties and interactive features for exploring the molecule's geometry.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[PlotConfig]</code> <p>Dictionary of visualization settings:</p> <ul> <li>atom_size (int): Size of atom markers (default: 7)</li> <li>atom_opacity (float): Opacity of atoms from 0.0-1.0 (default: 0.8)</li> <li>atom_border_color (str): Color of atom borders (default: \"lightgray\")</li> <li>atom_border_width (int): Width of atom borders (default: 2)</li> <li>bond_color (str): Color of bonds between atoms (default: \"grey\")</li> <li>bond_width (int): Width of bond lines (default: 2)</li> <li>show_grid (bool): Whether to display axis grid (default: False)</li> <li>label_offset (int): Vertical offset for labels (default: 15)</li> <li>bond_label_color (str): Color of bond length labels (default: \"steelblue\")</li> </ul> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title displayed above visualization (default: None)</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: Plotly figure object containing:</p> <ul> <li>3D scatter plot of atoms colored by element</li> <li>Line segments representing bonds</li> <li> <p>Interactive menu for toggling labels:</p> <ul> <li>Element symbols</li> <li>Atom indices</li> <li>Bond lengths</li> <li>Combinations of the above</li> </ul> </li> <li> <p>Mouse controls for rotation, zoom, and pan</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = mg.to_plotly(config={\n...     \"atom_size\": 12,\n...     \"atom_opacity\": 0.9,\n...     \"bond_color\": \"black\",\n...     \"show_grid\": True,\n...     \"label_offset\": 20\n... })\n&gt;&gt;&gt; fig.show()\n</code></pre> Source code in <code>xyz2graph/xyz2graph.py</code> <pre><code>def to_plotly(\n    self,\n    config: Optional[PlotConfig] = None,\n    title: Optional[str] = None,\n) -&gt; go.Figure:\n    \"\"\"Creates an interactive 3D visualization of the molecular structure.\n\n    Generates a Plotly figure displaying atoms as spheres and bonds as lines, with\n    configurable visual properties and interactive features for exploring the molecule's\n    geometry.\n\n    Args:\n        config (Optional[PlotConfig]): Dictionary of visualization settings:\n\n            - atom_size (int): Size of atom markers (default: 7)\n            - atom_opacity (float): Opacity of atoms from 0.0-1.0 (default: 0.8)\n            - atom_border_color (str): Color of atom borders (default: \"lightgray\")\n            - atom_border_width (int): Width of atom borders (default: 2)\n            - bond_color (str): Color of bonds between atoms (default: \"grey\")\n            - bond_width (int): Width of bond lines (default: 2)\n            - show_grid (bool): Whether to display axis grid (default: False)\n            - label_offset (int): Vertical offset for labels (default: 15)\n            - bond_label_color (str): Color of bond length labels (default: \"steelblue\")\n\n        title (Optional[str]): Title displayed above visualization (default: None)\n\n    Returns:\n        go.Figure: Plotly figure object containing:\n\n            - 3D scatter plot of atoms colored by element\n            - Line segments representing bonds\n            - Interactive menu for toggling labels:\n\n                - Element symbols\n                - Atom indices\n                - Bond lengths\n                - Combinations of the above\n\n            - Mouse controls for rotation, zoom, and pan\n\n    Examples:\n        &gt;&gt;&gt; fig = mg.to_plotly(config={\n        ...     \"atom_size\": 12,\n        ...     \"atom_opacity\": 0.9,\n        ...     \"bond_color\": \"black\",\n        ...     \"show_grid\": True,\n        ...     \"label_offset\": 20\n        ... })\n        &gt;&gt;&gt; fig.show()\n    \"\"\"\n    logger.debug(\"Creating Plotly figure\")\n\n    if not self.elements:\n        logger.warning(\"No molecular data to visualize\")\n        return go.Figure()\n\n    plot_config = DEFAULT_PLOT_CONFIG.copy()\n    if config:\n        plot_config.update(config)\n\n    # Create figure\n    data = [\n        self._create_atom_trace(plot_config),\n        self._create_bond_trace(plot_config),\n    ]\n\n    # Configure axis parameters\n    axis_params = dict(\n        showgrid=plot_config[\"show_grid\"],\n        showbackground=False,\n        showticklabels=False,\n        zeroline=False,\n        titlefont=dict(color=\"white\"),\n        showspikes=False,\n    )\n\n    # Build layout\n    layout = dict(\n        title=title,\n        scene=dict(\n            xaxis=axis_params,\n            yaxis=axis_params,\n            zaxis=axis_params,\n            annotations=self._create_annotations(plot_config, atom_label_type=\"element\"),\n        ),\n        margin=dict(r=0, l=0, b=0, t=0 if not title else 40),\n        showlegend=False,\n        updatemenus=[\n            dict(\n                buttons=self._create_menu_buttons(plot_config),\n                direction=\"down\",\n                xanchor=\"left\",\n                yanchor=\"top\",\n                pad=dict(r=10, t=10),\n            )\n        ],\n    )\n\n    logger.debug(\"Plotly figure created successfully\")\n    return go.Figure(data=data, layout=layout)\n</code></pre>"}]}